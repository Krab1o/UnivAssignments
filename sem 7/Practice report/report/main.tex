\documentclass[pract]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафдры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% Включение шрифта
%    times      - включение шрифта Times New Roman (если установлен)
%                 по умолчанию выключен
\usepackage{preamble}
% \captionsetup[figure]{font= normalsize, labelfont=normalsize}
\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работ
\title{Курс разработки Backend Web-приложения с \ DevOps принципами}

% Курс
\course{3}

% Группа
\group{351}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Устюшина Богдана Антоновича}

% Заведующий кафедрой 
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
%\chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{ст. преп., к.\,ф.-м.\,н.} %должность, степень, звание
\saname{М.\,И.\,Сафрончик}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{6}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{производственная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{4}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.08.2024}
\practFinish{28.08.2024}

% Год выполнения отчета
\date{2024}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
% \secNumbering

% \tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

\sloppy

\intro{}

Практика проходила на базе предприятия ООО <<ПрофСофт>> и заключалась в 
прохождении курса по Backend- и DevOps-разработке. 

В рамках курса велась над учебным проектом <<Анекдоты>>, в рамках которого
показывались лучшие практики в разработке серверной части приложений, а также
техники по поддержке и настройке CI/CD на проекте.

В процессе разработки использовались язык программирования PHP и
объектно-реляционная система управления базами данных PostgreSQL. Также в
рамках работы над DevOps задачами активно использовалась YAML-нотация для
написания настроечных файлов для pipeline на GitLab и написания 
выполняемых в рамках автоматизации работ.

Целью практики была разработка backend-части приложения.

В рамках производственной практики должны были быть решены следующие задачи:
\begin{enumerate}
    \item Построение схемы базы данных
    \item Создание базовых CRUD для backend-приложения
    \item Создание авторизации на основе концепции access- и refresh-токенов
    \item Создание docker-compose файлов для настройки
    контейнеризации и автоматизации запуска приложения  
\end{enumerate}

В процессе выполнения данных задач будет рассмотрено использование
лучших практик разработки веб-приложений, а также современные подходы
к организации рабочего процесса с акцентом на безопасность и масштабируемость
приложения.

\section{Описание проекта}

Современная веб-разработка является одной из самых динамично развивающихся 
областей информационных технологий. С каждым годом всё большее количество
компаний и организаций переносит свои сервисы и системы в онлайн-среду,
что требует создания надежных, масштабируемых и безопасных веб-приложений.
Особое внимание уделяется разработке серверной части (Backend), 
которая обеспечивает связь с базами данных, обработку запросов 
пользователей, а также взаимодействие с различными внешними системами. 
Веб-приложения, использующие язык программирования PHP и фреймворк 
Symfony, предоставляют широкие возможности для создания мощных и гибких
систем, особенно в сочетании с такими современными технологиями, как 
контейнеризация с Docker и использование веб-сервера Nginx. Это делает 
тему разработки серверной части веб-приложений крайне актуальной в 
контексте повышения производительности, гибкости и безопасности
веб-систем.

В данной работе будет рассматриваться процесс разработки серверной
части веб-приложения для обмена анекдотами на базе PHP и фреймворка 
Symfony. В процессе работы будет рассмотрено, как с помощью Docker
создать контейнеризированное окружение для разработки и развертывания
приложения, как настроить веб-сервер Nginx для обработки запросов, а также
как тестировать API с помощью Postman и документировать его с использованием
Swagger. Также будут освещены основные принципы работы с архитектурой 
MVC на Symfony и взаимодействие с базами данных через ORM Doctrine. 
Особое внимание будет уделено выбору и настройке средств разработки, 
таких как PHPStorm, а также сравнению PHP с другими популярными языками 
для создания Backend-приложений. Важной частью работы станет анализ 
производительности и безопасности разрабатываемого приложения в
контейнеризированной среде.

Целью производственной практики является приобретение навыков разработки 
серверной части веб-приложений с использованием современных инструментов 
и технологий, таких как PHP, Symfony, Docker, Nginx, Postman и Swagger
\cite{symfony_docs} \cite{robots_net_symfony}. 
Практика направлена на углубленное изучение архитектуры веб-приложений, 
принципов работы серверной части и интеграции различных инструментов 
для разработки, тестирования и развертывания приложений 
\cite{postman_api_testing} \cite{postman_docs} \cite{nginx_docs}.

Кроме того, значительное внимание будет уделено изучению особенностей
контейнеризации и управления окружением разработки с помощью Docker,
что позволит улучшить навыки работы с современными DevOps-технологиями.

\section{Выполненные в рамках проекта задачи}

\subsection{Построение схемы базы данных}

\subsubsection{Постановка задачи}

Построить схему базы данных для данной предметной области (анекдоты) и 
представить её в виде ER-диаграммы.

\subsubsection{Решение}

Для начала опишем структуру таблиц, которые использовались для построения
изображения, а затем предоставим SQL-запросы для их создания \cite{postgresql}.

Структура таблиц:

\begin{itemize}
    \item Анекдот ­— сущность использовалась для хранения информации об 
    анекдоте. Сущность включала следующие поля:
    \begin{enumerate}
        \item id (Primary Key): идентификатор.
        \item title: заголовок.
        \item text: текст анекдота.
        \item category: категория.
        \item author\_id (Foreign Key): ссылка на пользователя.
    \end{enumerate}

    \item User — сущность, использующаяся для хранения информации о 
    пользователе. Сущность включала следующие поля:
    \begin{enumerate}
        \item id (Primary Key): идентификатор пользователя.
        \item surname: фамилия.
        \item name: имя.
        \item patronym: отчество.
        \item email: электронная почта.
    \end{enumerate}
        
    \item Mark — сущность, использующаяся для хранения информации об оценке,
    которую пользователь мог поставить анекдоту. Сущность включала следующие 
    поля:
    \begin{enumerate}
        \item user\_id (Primary Key, Foreign Key): cсылка на пользователя.
        \item anec\_id (Primary Key, Foreign Key): Ссылка на анекдот.
        \item value: Оценка.
    \end{enumerate}

    \item Code — сущность, использующаяся для хранения информации о коде
    подтверждения email пользователя при регистрации.
    \begin{enumerate}
        \item id (Primary Key): идентификатор.
        \item code: код.
        \item user\_id (Foreign Key): ссылка на пользователя.
        \item expired\_at: время истечения срока действия.
    \end{enumerate}
\end{itemize}

\begin{minted}[linenos, breaklines=true, style=bw]{PostgreSQL}
-- Таблица User
CREATE TABLE User (
    id SERIAL PRIMARY KEY,
    sur VARCHAR(100) NOT NULL,
    name VARCHAR(100) NOT NULL,
    patr VARCHAR(100),
    email VARCHAR(255) UNIQUE NOT NULL
);

-- Таблица Anecdote
CREATE TABLE Anecdote (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    text TEXT NOT NULL,
    category VARCHAR(100),
    author_id INT REFERENCES User(id) ON DELETE CASCADE
);

-- Таблица Mark
CREATE TABLE Mark (
    user_id INT REFERENCES User(id) ON DELETE CASCADE,
    anec_id INT REFERENCES Anecdote(id) ON DELETE CASCADE,
    value INT NOT NULL CHECK (value >= 1 AND value <= 5),
    PRIMARY KEY (user_id, anec_id)
);

-- Таблица Code
CREATE TABLE Code (
    id SERIAL PRIMARY KEY,
    code VARCHAR(100) NOT NULL,
    user_id INT REFERENCES User(id) ON DELETE CASCADE,
    expired_at TIMESTAMP NOT NULL
);
\end{minted}

Для создания схемы базы данных использовался как язык SQL, так и ORM-модели.

ORM (Object-Relational Mapping) — это технология, которая позволяет 
разработчикам работать с базами данных, используя объектно-ориентированный 
подход. ORM автоматически преобразует данные из базы данных (реляционные 
таблицы) в объекты языка программирования и наоборот.

ORM-модель — это объектно-ориентированное представление таблицы базы данных. 
Каждая таблица в базе данных соответствует классу в коде, а строки таблицы 
представлены как экземпляры этого класса.

В нашем случае Doctrine сгенерировала следующую миграцию, которую впоследствии
применили к БД:

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
public function getDescription(): string
{
    return 'Creating first database schema';
}

public function up(Schema $schema): void
{
    // this up() migration is auto-generated, please modify it to your needs
    $this->addSql('CREATE SEQUENCE anecdote_id_seq INCREMENT BY 1 MINVALUE 1 START 1');
    $this->addSql('CREATE SEQUENCE "user_id_seq" INCREMENT BY 1 MINVALUE 1 START 1');
    $this->addSql('CREATE TABLE anecdote (id INT NOT NULL, author_id_id INT NOT NULL, title VARCHAR(255) NOT NULL, text VARCHAR(255) NOT NULL, category VARCHAR(127) NOT NULL, PRIMARY KEY(id))');
    $this->addSql('CREATE INDEX IDX_A5051EEC69CCBE9A ON anecdote (author_id_id)');
    $this->addSql('CREATE TABLE code (id INT NOT NULL, code VARCHAR(255) NOT NULL, user_id_id INT NOT NULL, expired_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, PRIMARY KEY(id, code))');
    $this->addSql('CREATE INDEX IDX_771530989D86650F ON code (user_id_id)');
    $this->addSql('COMMENT ON COLUMN code.expired_at IS \'(DC2Type:datetime_immutable)\'');
    $this->addSql('CREATE TABLE mark (user_id_id INT NOT NULL, anecdote_id_id INT NOT NULL, value INT NOT NULL, PRIMARY KEY(user_id_id, anecdote_id_id))');
    $this->addSql('CREATE INDEX IDX_6674F2719D86650F ON mark (user_id_id)');
    $this->addSql('CREATE INDEX IDX_6674F271A347EF68 ON mark (anecdote_id_id)');
    $this->addSql('CREATE TABLE "user" (id INT NOT NULL, surname VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, patronymic VARCHAR(255) DEFAULT NULL, email VARCHAR(255) NOT NULL, PRIMARY KEY(id))');
    $this->addSql('ALTER TABLE anecdote ADD CONSTRAINT FK_A5051EEC69CCBE9A FOREIGN KEY (author_id_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
    $this->addSql('ALTER TABLE code ADD CONSTRAINT FK_771530989D86650F FOREIGN KEY (user_id_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
    $this->addSql('ALTER TABLE mark ADD CONSTRAINT FK_6674F2719D86650F FOREIGN KEY (user_id_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
    $this->addSql('ALTER TABLE mark ADD CONSTRAINT FK_6674F271A347EF68 FOREIGN KEY (anecdote_id_id) REFERENCES anecdote (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
}
\end{minted}

Таким образом, была создана схема базы данных.

\subsection{Создание базовых CRUD для Backend-приложения}
\subsubsection{Постановка задачи}
Построить CRUD (API) PHP-приложения на фреймворке Symfony для функционирования
Backend-приложения. 
\subsubsection{Решение}

Преимущества использования Symfony для REST API
\begin{enumerate}
    \item Автоматизация: Генерация кода упрощает создание API.
    \item Мощный ORM: Doctrine облегчает управление базой данных.
    \item API Platform: Symfony интегрируется с API Platform для создания сложных API.
    \item Валидация: Простая интеграция с системой валидации данных.
    \item Гибкость: Легко добавлять middleware, авторизацию и другие механизмы.
\end{enumerate}

Symfony — это мощный PHP-фреймворк, который упрощает создание REST API.

Для решения данной задачи требовалось:

\begin{enumerate}
    \item Создать DTO с помощью инструментов PHP-фреймворка Symfony
    \item Создать класс-контроллер для сущности Anecdote
    \item Создать бизнес-логику для указанных endpoint из вышеописанного
    контроллера
\end{enumerate}

Рассмотрим пример на одной из сущностей (анекдоте): остальные реализовались по
аналогичному сценарию.

Создание DTO для запроса:

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
class AnecdoteBaseRequestDTO
{
    public function __construct(
        #[Assert\NotNull(groups: ['register'])]
        #[Assert\Type(type: 'string', groups: ['register', 'edit'])]
        #[Assert\Length(max: 127, groups: ['register', 'edit'])]
        public ?string $title = null,

        #[Assert\NotNull(groups: ['register'])]
        #[Assert\Type(type: 'string', groups: ['register', 'edit'])]
        public ?string $text = null,

        #[Assert\NotNull(groups: ['register'])]
        #[Assert\Type(type: 'string', groups: ['register', 'edit'])]
        public ?bool $category = null,
    ) { }
}
\end{minted}

Создание DTO для ответа:

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
class AnecdoteBaseResponseDTO
{
    public int $id;
    public string $title;
    public string $text;
    public string $category;

    public function __construct(Anecdote $anecdote)
    {
        $this->id = $anecdote->getId();
        $this->title = $anecdote->getTitle();
        $this->text = $anecdote->getText();
        $this->category = $anecdote->getCategory();
    }
}
\end{minted}

Создание контроллера для сущности anecdote с относительным URI 
\texttt{\/anecdote}:

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
#[Route(path: '/anecdote')]
class AnecdoteController extends AbstractController
{
    public function __construct(
        private readonly ValidatorService    $validator,
        private readonly SerializerInterface $serializer,
    ) { }
    #[Route(path: '', name: 'apiGetAnecdoteList', methods: Request::METHOD_GET)]
    public function getAnecdoteList(AnecdoteService $anecdoteService): JsonResponse
    {
        return $this->json(
            data: $anecdoteService->getAnecdoteList(),
            status: Response::HTTP_OK,
        );
    }
    #[Route(path: '', name: 'apiCreateAnecdote', methods: Request::METHOD_POST)]
    public function createUser(Request $request, AnecdoteService $anecdoteService): JsonResponse
    {
        $data = $this->serializer->deserialize($request->getContent(), AnecdoteBaseRequestDTO::class, 'json');
        $this->validator->validate(body: $data, groupsBody: ['register']);
        return $this->json(
            data: $anecdoteService->createAnecdote($data),
            status: Response::HTTP_CREATED,
        );
    }
    #[Route(path: '/{id<\d+>}', name: 'apiEditAnecdote', methods: Request::METHOD_PATCH)]
    public function editAnecdote(
        Anecdote        $id,
        Request         $request,
        AnecdoteService $anecdoteService,
    ): JsonResponse
    {
        $data = $this->serializer->deserialize($request->getContent(), AnecdoteBaseRequestDTO::class, 'json');
        $this->validator->validate(body: $data, groupsBody: ['edit']);

        return $this->json(
            data: $anecdoteService->editAnecdote($id, $data),
            status: Response::HTTP_CREATED,
        );
    }
    #[Route(path: '/{id<\d+>}', name: 'apiDeleteAnecdote', methods: Request::METHOD_DELETE)]
    public function deleteUser(Anecdote $id, AnecdoteService $anecdoteService): JsonResponse
    {
        $anecdoteService->deleteAnecdote($id);

        return $this->json(
            data: [],
            status: Response::HTTP_NO_CONTENT,
        );
    }
}
\end{minted}

В данном коде представлены основные операции с сущностью Anecdote: создание,
обновление, чтение, удаление. Это реализуется с помощью вызова у переменной
\texttt{\$anecdoteService} методов create, edit и прочих.

Сама же переменная \$anecdoteService является объектом класса
AnecdoteService, в котором хранится вся бизнес-логика методов, связанных с 
сущностью Anecdote. 

Рассмотрим один из методов: их логика достаточно тривиальна:

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
public function editAnecdote(Anecdote $anecdote, AnecdoteBaseRequestDTO $DTO): AnecdoteBaseResponseDTO
{
    if ($title = $DTO->title) {
        $anecdote->setTitle($title);
    }
    if ($text = $DTO->text) {
        $anecdote->setText($text);
    }
    if ($category = $DTO->category) {
        $anecdote->setCategory($category);
    }
    $this->entityManager->flush();
    return new AnecdoteBaseResponseDTO($anecdote);
}
\end{minted}

Таким образом, при последующем использовании кода были выявлены следующие
преимущества данного подхода к решению задачи: 

\begin{enumerate}
    \item DTO позволяет отделить внутренние модели приложения от структуры 
    данных, передаваемых клиенту, что упрощает форматирование ответов и 
    защиту чувствительных данных.
    \item Контроллеры обеспечивают чистую организацию кода, выступая 
    посредниками между бизнес-логикой и клиентами API, обрабатывая запросы, 
    вызовы сервисов и формирование ответов \cite{rest_api_tutorial}
    \cite{microsoft_rest_api} \cite{aws_rest_api}.
\end{enumerate}

\subsection{Создание авторизации на основе концепции access- и refresh-токенов}
\subsubsection{Постановка задачи}
Создать механизм авторизации на языке PHP с помощью access- и refresh-токенов.

\subsubsection{access- и refresh-токены}

Использование access и refresh токенов — это подход для безопасной и 
удобной аутентификации пользователей, часто применяемый в системах с 
использованием JWT (JSON Web Tokens). Этот метод позволяет минимизировать 
риски, связанные с компрометацией токенов, и улучшить пользовательский опыт 
за счёт автоматического обновления сессии.

\textbf{Access-токен} — краткоживущий токен, содержащий информацию об 
аутентификации пользователя (например, ID, роли и права доступа). Используется 
для выполнения запросов к защищённым ресурсам API. Имеет короткий срок действия
(например, 15 минут), что снижает последствия его утечки.

\textbf{Refresh-токен} — долгоживущий токен, используемый только для получения 
нового access-токена. Не используется напрямую для доступа к API. Хранится в 
более защищённом месте (например, в HTTP-only cookies), чтобы минимизировать 
риск его утечки.

\textbf{Алгоритм работы системы}:

\begin{enumerate}
    \item Пользователь аутентифицируется (например, с помощью логина и пароля).
    \item Сервер выдаёт:
    \begin{enumerate}
        \item Access-токен для доступа к ресурсам API.
        \item Refresh-токен для продления действия сессии.
    \end{enumerate}
    \item Клиент отправляет access-токен в каждом запросе к API 
    (обычно в заголовке Authorization: Bearer <token>).
    \item Если access-токен истёк, клиент использует refresh-токен, 
    чтобы получить новый access-токен через специальный API-эндпоинт.
    \item Если refresh-токен истёк, пользователь должен пройти повторную 
    аутентификацию \cite{baeldung_tokens} \cite{auth0_refresh_tokens}.
\end{enumerate}

\subsubsection{Решение}

Для выполнения задачи требуется выполнить следующее:

\begin{enumerate}
    \item Создать сущность Device и добавить её в базу данных. Указать В
    ней два токена - access и refresh, у каждого своё время жизни.
    \item Реализовать проверку на время жизни токена в ApiAuthenticator.
    \item Реализовать метод обновления времени жизни access токена.
    \item Добавить функционал отправки письма на почту при регистрации
    с помощью MailerService
\end{enumerate}

Все эти шаги описаны в классе SecurityService, код которого содержится в 
приложении \ref{appendA}.

\subsection{Создание docker-compose файлов для настройки
    контейнеризации и автоматизации запуска приложения}
\subsubsection{Постановка задачи}
Создать автоматизацию контейнеризации с помощью docker и docker-compose
в .yaml файле.

\subsubsection{Docker и docker compose}

Преимущества Docker:
\begin{enumerate}
    \item Изоляция среды. Docker контейнеры изолируют приложения и их 
    зависимости, что позволяет избежать конфликтов с локальной средой 
    разработчика или сервером. Каждое приложение запускается в своей среде, 
    не влияя на другие.

    \item Универсальность и совместимость. Контейнеры гарантируют, что 
    приложение будет работать одинаково на любом хосте, где установлен 
    Docker (локальная машина, сервер, облако).

    \item Быстрое развертывание. Запуск контейнера занимает секунды, так как
     он использует легковесные образы, а не тяжелые виртуальные машины.

    \item Повторяемость. С использованием Dockerfile можно точно 
    задокументировать и воспроизвести среду разработки и продакшн.

    \item Легкость тестирования. Тестирование в изолированной среде Docker 
    помогает обнаружить проблемы, которые могут проявиться в реальном продакшне.

    \item Упрощенная миграция и масштабирование. Легко переносить приложение 
    между средами (локальная разработка, staging, production). Контейнеры 
    масштабируются горизонтально с помощью оркестрации (например, Kubernetes 
    или Docker Swarm).
\end{enumerate}
    

\subsubsection{Решение}

Контейнеризация с помощью Docker Compose позволяет легко управлять 
многокомпонентными приложениями, описывая их инфраструктуру (контейнеры, 
сети, тома) в одном файле docker-compose.yml. Это упрощает настройку, 
запуск и масштабирование, позволяя разработчикам и командам быстро 
развертывать целые приложения с зависимостями (например, серверы, 
базы данных) с помощью одной команды (docker-compose up).

Для решения напишем .yaml файл, который как раз будет контролировать запуск 
сервисов, описанных в docker compose.

\begin{minted}[linenos, breaklines=true, style=bw]{YAML}
version: '3.9'

services:
    nginx:
    build:
        context: ./build/nginx
        dockerfile: Dockerfile
    container_name: nginx-task3
    volumes:
        - ./app/public:/var/www/app/public/:ro
        - ./build/nginx/config:/etc/nginx/conf.d/:ro
    ports: 
        - 8080:80
    networks:
        - default
    
    db:
    image: postgres:15.2-alpine3.17
    container_name: db-task3
    environment:
        POSTGRES_PASSWORD: postgres
        POSTGRES_DB: db
        POSTGRES_USER": krab1o
        POSTGRES_HOST: krab1ocomp
    volumes:
        - db_volume:/var/lib/postgresql/data
    networks:
        - default

    php:
    build:
        context: ./build/php
        dockerfile: Dockerfile
    container_name: php-task3
    volumes:
        - ./app:/var/www/app
    networks:
        - default
networks:
    default:
volumes:
    db_volume:
\end{minted}

При этом docker-compose использует два кастомных Docker-образа, которые 
описаны ниже.

Здесь представлен Docker-файл для сервиса nginx:

\begin{minted}[linenos, breaklines=true, style=bw]{YAML}
FROM php:fpm-alpine3.20 as php_upstream
FROM composer/composer:2-bin

FROM php_upstream as php_base

WORKDIR /var/www/app

RUN apk update && apk upgrade && apk add php php-fpm

COPY --from=composer /usr/bin/composer /usr/bin/composer

EXPOSE 9000

CMD ["php-fpm"]
\end{minted}

А здесь — для сервиса backend PHP:

\begin{minted}[linenos, breaklines=true, style=bw]{YAML}
FROM nginx:stable-alpine

WORKDIR /var/www

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]    
\end{minted}

Таким образом, приложение на PHP с сервисом базы данных и сервером nginx,
который выполняет функцию reverse-proxy, поднимается с помощью docker compose,
а кастомные команды, которые требуется выполнить в образах сервера и 
backend-приложения, описаны в Dockerfile \cite{docker} \cite{docker_docs}.

\conclusion

В ходе выполнения данной работы были изучены современные инструменты и 
технологии для разработки серверной части веб-приложений. В частности, 
были рассмотрены особенности работы с языком PHP и фреймворком Symfony, 
а также разработана архитектура приложения на основе MVC. 

Настроено контейнеризированное окружение с использованием Docker и веб-сервера 
Nginx для обеспечения эффективной и стабильной работы приложения. Особое 
внимание уделялось тестированию RESTful API с помощью Postman и 
документированию его с использованием Swagger. Также проведен анализ 
преимуществ и недостатков применяемых технологий в контексте разработки 
масштабируемых и безопасных веб-приложений. 

Перспективы применения результатов данной работы достаточно широки. 

Во-первых, разработанное приложение может быть использовано как основа 
для дальнейшего развития и расширения функциональности, например, для 
добавления новых типов контента или внедрения системы рекомендаций на 
основе предпочтений пользователей. 

Во-вторых, контейнеризация с использованием Docker позволяет легко 
масштабировать приложение и развертывать его в различных окружениях, 
что важно для гибкости и мобильности современных веб-сервисов. 

Применение Nginx как веб-сервера повышает производительность и надежность 
работы приложения при обработке большого количества запросов, что открывает 
возможности для использования данного решения в высоконагруженных системах. 
Кроме того, навыки тестирования и документирования API с Postman и Swagger 
могут быть применены в разработке других проектов, требующих четкой и 
структурированной документации интерфейсов.

Таким образом, созданный проект достигнул поставленных задач школы ProfSoft,
цель производственной практики была достигнута, а все поставленные в ходе
практики задачи решены.

\inputencoding{cp1251}
\bibliographystyle{gost780uv}
\bibliography{thesis.bib}
\inputencoding{utf8}

\appendix

\section{Создание авторизации}
\label{appendA}

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
class SecurityService
{
    private const string SUBJECT = 'Код авторизации';

    private const string ACCESS_TOKEN_LIFETIME = '+10 minutes';
    private const string REFRESH_TOKEN_LIFETIME = '+90 days';

    public function __construct(
        #[Autowire(service: YandexMailerService::class)]
        private MailerServiceInterface   $mailer,
        protected EntityManagerInterface $entityManager,
    ) { }
    public function sendCode(LoginDTO $DTO): void
    {
        $code = new Code();
        if (!$this->entityManager->getRepository(User::class)->
        findOneByEmail($DTO->email) instanceof User) {
            throw new ApiException(
                message: "Пользователь по указанному email не найден",
                status: Response::HTTP_NOT_FOUND,
            );
        }
        $code
            ->setEmail($DTO->email);

        $this->entityManager->persist($code);
        $this->entityManager->flush();
        $this->mailer->send(self::SUBJECT, $code->getCode(), (array)$DTO->email);
    }

    public function verifyCode(LoginDTO $DTO): array
    {
        $code = $this->entityManager->getRepository(Code::class)->
        findOneBy([
            'code' => $DTO->code,
            'email' => $DTO->email,
            'status' => CodeStatus::ACTIVE->value,
        ]);

        if (!$code instanceof Code) {
            throw new ApiException(
                'Неверный код авторизации',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }
        if ($code->getExpiredAt() < new \DateTime()) {
            $code
                ->setStatus(CodeStatus::EXPIRED->value);
            $this->entityManager->flush();
            throw new ApiException(
                'Код авторизации истек',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }
        $owner = $this->entityManager->getRepository(User::class)->
        findOneBy([
            'email' => $DTO->email,
        ]);

        $device = (new Device())
            ->setOwner($owner)
            ->setTokenExpiresAt((new \DateTime())->modify(self::ACCESS_TOKEN_LIFETIME))
            ->setRefreshTokenExpiresAt((new \DateTime())->modify(self::REFRESH_TOKEN_LIFETIME));
        
        $code
            ->setStatus(CodeStatus::INACTIVE->value);

        $this->entityManager->persist($device);
        $this->entityManager->flush();

        return [
            'token' => $device->getToken(),
            'refreshToken' => $device->getRefreshToken(),
        ];
    }
    public function logout(string $apikey): void
    {
        $device = $this->entityManager->getRepository(Device::class)->
        findOneBy([
            'apikey' => $apikey,
        ]);
        $device->setStatus(DeviceStatus::INACTIVE->value);
        $this->entityManager->flush();
    }
    public function refresh(?string $refreshToken): array {
        $device = $this->entityManager->getRepository(Device::class)->
        findOneBy([
            'refreshToken' => $refreshToken,
            'status' => DeviceStatus::ACTIVE->value,
        ]);

        if (!$device instanceof Device) {
            throw new ApiException(
                message: 'Некорректный refresh токен',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }

        if ($device->getRefreshTokenExpiresAt() < new \DateTime()) {
            $device->setStatus(DeviceStatus::EXPIRED->value);
            $this->entityManager->flush();

            throw new ApiException(
                message: 'Refresh токен истёк',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }

        $device
            ->setToken($this->generateToken())
            ->setTokenExpiresAt((new \DateTime())->modify(self::ACCESS_TOKEN_LIFETIME))
            ->setRefreshToken($this->generateToken());

        $this->entityManager->flush();

        return [
            'token' => $device->getToken(),
            'refreshToken' => $device->getRefreshToken(),
        ];
    }
    public function generateToken(): string {
        return md5(random_int(100000, 999999) . microtime());
    }
}
\end{minted}

\end{document}
