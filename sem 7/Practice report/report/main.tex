\documentclass[pract]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафдры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% Включение шрифта
%    times      - включение шрифта Times New Roman (если установлен)
%                 по умолчанию выключен
\usepackage{preamble}
% \captionsetup[figure]{font= normalsize, labelfont=normalsize}
\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работ
\title{Курс разработки Backend Web-приложения с \ DevOps принципами}

% Курс
\course{3}

% Группа
\group{351}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Устюшина Богдана Антоновича}

% Заведующий кафедрой 
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
%\chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{ст. преп., к.\,ф.-м.\,н.} %должность, степень, звание
\saname{М.\,И.\,Сафрончик}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{6}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{производственная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{4}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.08.2024}
\practFinish{28.08.2024}

% Год выполнения отчета
\date{2024}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
% \secNumbering

% \tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

\sloppy

\intro{}

Практика проходила на базе предприятия ООО <<ПрофСофт>> и заключалась в 
прохождении курса по Backend- и DevOps-разработке.

Основным направлением деятельности компании является разработка и поддержка
цифровых продуктов, мобильных, web-приложений, сервисов и готовых решений 
для бизнеса и людей. Также компания ежегодно проводит школу, в рамках которой
на каждом из направлений на практике объясняются основы и лучшие практики
разработки IT-продуктов. 

В рамках курса велась над учебным проектом <<Анекдоты>>, в рамках которого
показывались лучшие практики в разработке серверной части приложений, а также
техники по поддержке и настройке CI/CD на проекте.

В процессе разработки использовались язык программирования PHP и
объектно-реляционная система управления базами данных PostgreSQL. Также в
рамках работы над DevOps задачами активно использовалась YAML-нотация для
написания настроечных файлов для pipeline на GitLab и написания 
выполняемых в рамках автоматизации работ.

Целью практики была разработка backend-части приложения.

В рамках производственной практики должны были быть решены следующие задачи:
\begin{enumerate}
    \item Построение схемы базы данных
    \item Создание базовых CRUD для backend-приложения
    \item Создание авторизации на основе концепции access- и refresh-токенов
    \item Создание docker-compose файлов для настройки
    контейнеризации и автоматизации запуска приложения  
\end{enumerate}

В процессе выполнения данных задач будет рассмотрено использование
лучших практик разработки веб-приложений, а также современные подходы
к организации рабочего процесса с акцентом на безопасность и масштабируемость
приложения.

\section{Описание проекта}

Современная веб-разработка является одной из самых динамично развивающихся 
областей информационных технологий. С каждым годом всё большее количество
компаний и организаций переносит свои сервисы и системы в онлайн-среду,
что требует создания надежных, масштабируемых и безопасных веб-приложений.
Особое внимание уделяется разработке серверной части (Backend), 
которая обеспечивает связь с базами данных, обработку запросов 
пользователей, а также взаимодействие с различными внешними системами.

Рассмотрим технологии, которые активно использовались в процессе прохождения
курсов озвученной выше школы.

Веб-приложения, использующие язык программирования PHP и фреймворк 
Symfony, предоставляют широкие возможности для создания мощных и гибких
систем, особенно в сочетании с такими современными технологиями, как 
контейнеризация с Docker и использование веб-сервера Nginx. Это делает 
тему разработки серверной части веб-приложений крайне актуальной в 
контексте повышения производительности, гибкости и безопасности
веб-систем.

В данной работе будет рассматриваться процесс разработки серверной
части веб-приложения для обмена анекдотами на базе PHP и фреймворка 
Symfony. 

В процессе работы будет рассмотрено, как с помощью Docker
создать контейнеризированное окружение для разработки и развертывания
приложения, как настроить веб-сервер Nginx для обработки запросов, а также
как тестировать API с помощью Postman и документировать его с использованием
Swagger. Также будут освещены основные принципы работы с архитектурой 
MVC на Symfony и взаимодействие с базами данных через ORM Doctrine. 
Особое внимание будет уделено выбору и настройке средств разработки, 
таких как PHPStorm, а также сравнению PHP с другими популярными языками 
для создания Backend-приложений. 

Важной частью работы станет анализ производительности и безопасности 
разрабатываемого приложения в контейнеризированной среде Docker, а также его
автоматизация с помощью Gitlab pipelines.

Целью производственной практики является приобретение навыков разработки 
серверной части веб-приложений с использованием современных инструментов 
и технологий, таких как PHP, Symfony, Docker, Nginx, Postman и Swagger
\cite{symfony_docs, robots_net_symfony}.

Практика направлена на углубленное изучение архитектуры веб-приложений, 
принципов работы серверной части и интеграции различных инструментов 
для разработки, тестирования и развертывания приложений 
\cite{postman_api_testing, postman_docs, nginx_docs}.

Кроме того, значительное внимание будет уделено изучению особенностей
контейнеризации и управления окружением разработки с помощью Docker,
что позволит улучшить навыки работы с современными DevOps-технологиями.

\section{Выполненные в рамках проекта задачи}

\subsection{Построение схемы базы данных}

\subsubsection{Постановка задачи}

Построить схему базы данных для данной предметной области (анекдоты) и 
представить её в виде ER-диаграммы.

\subsubsection{Особенности СУБД PostgreSQL}

PostgreSQL (или просто Postgres) — это объектно-реляционная система управления 
базами данных (СУБД), которая используется для хранения, управления и 
обработки структурированных данных. Она обладает открытым исходным кодом и 
распространяется под лицензией PostgreSQL License, что делает её доступной 
для использования в коммерческих и некоммерческих проектах.

Основные характеристики PostgreSQL:
\begin{enumerate}
    \item Объектно-реляционная модель. PostgreSQL сочетает в себе возможности 
    реляционных баз данных с объектно-ориентированными функциями, такими как 
    пользовательские типы данных, наследование таблиц и поддержка сложных 
    структур данных.

    \item Расширяемость.
    PostgreSQL предоставляет гибкие возможности для расширения функционала. 
    Пользователи могут добавлять свои типы данных, функции, агрегаты, 
    операторы, индексы и даже языки для написания хранимых процедур.

    \item Мощный SQL-движок.
    PostgreSQL поддерживает стандарт SQL в сочетании с расширениями, такими 
    как оконные функции, CTE (общие табличные выражения) и JSON, что делает 
    её подходящей для сложных аналитических запросов.

    \item Масштабируемость и производительность.
    PostgreSQL поддерживает горизонтальное масштабирование с использованием 
    репликации и шардирования, а также вертикальное масштабирование за счёт 
    оптимизированного использования ресурсов процессора и памяти.

    \item Надёжность и отказоустойчивость.
    PostgreSQL обеспечивает надёжное хранение данных с помощью транзакций, 
    поддерживающих свойства ACID (атомарность, согласованность, изоляция, 
    долговечность). Также поддерживается механизм WAL (журнал записи), который 
    гарантирует восстановление данных в случае сбоя.

    \item Поддержка различных типов данных:
    PostgreSQL поддерживает не только стандартные типы данных (числа, строки, 
    даты), но и географические данные через расширение PostGIS, JSON/JSONB 
    для работы с неструктурированными данными и массивы.
\end{enumerate}

Архитектура PostgreSQL построена на многоуровневой модели. Основными 
компонентами являются:
\begin{enumerate}
    \item Сервер базы данных: Отвечает за управление соединениями, выполнение 
    запросов и управление данными.
    \item Ядро SQL: Обеспечивает обработку SQL-запросов, включая 
    синтаксический анализ, оптимизацию и выполнение.
    \item Хранилище данных: Реализует физическое хранение данных в виде 
    файлов на диске.
    \item Механизм транзакций: Гарантирует согласованность данных и 
    поддерживает механизм блокировок для параллельной работы.
\end{enumerate}

\subsubsection{Решение}

Для начала опишем структуру таблиц, которые использовались для построения
изображения, а затем предоставим SQL-запросы для их создания \cite{postgresql}.

Структура таблиц:

\begin{itemize}
    \item Анекдот ­— сущность использовалась для хранения информации об 
    анекдоте. Сущность включала следующие поля:
    \begin{enumerate}
        \item id (Primary Key): идентификатор.
        \item title: заголовок.
        \item text: текст анекдота.
        \item category: категория.
        \item author\_id (Foreign Key): ссылка на пользователя.
    \end{enumerate}

    \item User — сущность, использующаяся для хранения информации о 
    пользователе. Сущность включала следующие поля:
    \begin{enumerate}
        \item id (Primary Key): идентификатор пользователя.
        \item surname: фамилия.
        \item name: имя.
        \item patronym: отчество.
        \item email: электронная почта.
    \end{enumerate}
        
    \item Mark — сущность, использующаяся для хранения информации об оценке,
    которую пользователь мог поставить анекдоту. Сущность включала следующие 
    поля:
    \begin{enumerate}
        \item user\_id (Primary Key, Foreign Key): cсылка на пользователя.
        \item anec\_id (Primary Key, Foreign Key): Ссылка на анекдот.
        \item value: Оценка.
    \end{enumerate}

    \item Code — сущность, использующаяся для хранения информации о коде
    подтверждения email пользователя при регистрации.
    \begin{enumerate}
        \item id (Primary Key): идентификатор.
        \item code: код.
        \item user\_id (Foreign Key): ссылка на пользователя.
        \item expired\_at: время истечения срока действия.
    \end{enumerate}
\end{itemize}

% \begin{minted}[linenos, breaklines=true, style=bw]{PostgreSQL}
% -- Таблица User
% CREATE TABLE User (
%     id SERIAL PRIMARY KEY,
%     sur VARCHAR(100) NOT NULL,
%     name VARCHAR(100) NOT NULL,
%     patr VARCHAR(100),
%     email VARCHAR(255) UNIQUE NOT NULL
% );

% -- Таблица Anecdote
% CREATE TABLE Anecdote (
%     id SERIAL PRIMARY KEY,
%     title VARCHAR(255) NOT NULL,
%     text TEXT NOT NULL,
%     category VARCHAR(100),
%     author_id INT REFERENCES User(id) ON DELETE CASCADE
% );

% -- Таблица Mark
% CREATE TABLE Mark (
%     user_id INT REFERENCES User(id) ON DELETE CASCADE,
%     anec_id INT REFERENCES Anecdote(id) ON DELETE CASCADE,
%     value INT NOT NULL CHECK (value >= 1 AND value <= 5),
%     PRIMARY KEY (user_id, anec_id)
% );

% -- Таблица Code
% CREATE TABLE Code (
%     id SERIAL PRIMARY KEY,
%     code VARCHAR(100) NOT NULL,
%     user_id INT REFERENCES User(id) ON DELETE CASCADE,
%     expired_at TIMESTAMP NOT NULL
% );
% \end{minted}

Для создания схемы базы данных использовался как язык SQL, так и ORM-модели.

ORM (Object-Relational Mapping) — это технология, которая позволяет 
разработчикам работать с базами данных, используя объектно-ориентированный 
подход. ORM автоматически преобразует данные из базы данных (реляционные 
таблицы) в объекты языка программирования и наоборот.

ORM-модель — это объектно-ориентированное представление таблицы базы данных. 
Каждая таблица в базе данных соответствует классу в коде, а строки таблицы 
представлены как экземпляры этого класса.

ORM-сущность, которая используется при работе с фреймворком Symfony является
Doctrine.

Doctrine — это мощный набор библиотек на языке PHP, предназначенных для 
работы с базами данных. Наиболее известный компонент Doctrine, как уже было
упомянуто выше, это Doctrine ORM (Object-Relational Mapping), который 
предоставляет возможность связывать объекты PHP с реляционными таблицами 
баз данных.

Основные компоненты Doctrine:
\begin{enumerate}
    \item Doctrine ORM:
    \begin{itemize}
        \item Инструмент для объектно-реляционного отображения.
        \item Позволяет работать с базой данных через объекты, избегая 
        необходимости написания SQL-запросов.
        \item Сопоставляет классы и их свойства с таблицами и столбцами в 
        базе данных.
    \end{itemize}
        
    \item Doctrine DBAL (Database Abstraction Layer):
    \begin{itemize}
        \item Упрощает выполнение низкоуровневых операций с базой данных.
        \item Поддерживает работу с различными СУБД, используя 
        унифицированный интерфейс.
    \end{itemize}
        
    \item Doctrine Migrations — обеспечивает управление версионированием 
    схемы базы данных через миграции.

    \item Doctrine Common — Содержит базовые функции и утилиты, используемые 
    в других компонентах Doctrine.

\end{enumerate}
    
В нашем случае Doctrine сгенерировала следующую миграцию, которую впоследствии
применили к БД:

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
public function up(Schema $schema): void
{
    $this->addSql('CREATE SEQUENCE anecdote_id_seq INCREMENT BY 1 MINVALUE 1 START 1');
    $this->addSql('CREATE SEQUENCE "user_id_seq" INCREMENT BY 1 MINVALUE 1 START 1');
    $this->addSql('CREATE TABLE anecdote (id INT NOT NULL, author_id_id INT NOT NULL, title VARCHAR(255) NOT NULL, text VARCHAR(255) NOT NULL, category VARCHAR(127) NOT NULL, PRIMARY KEY(id))');
    $this->addSql('CREATE INDEX IDX_A5051EEC69CCBE9A ON anecdote (author_id_id)');
    $this->addSql('CREATE TABLE code (id INT NOT NULL, code VARCHAR(255) NOT NULL, user_id_id INT NOT NULL, expired_at TIMESTAMP(0) WITHOUT TIME ZONE NOT NULL, PRIMARY KEY(id, code))');
    $this->addSql('CREATE INDEX IDX_771530989D86650F ON code (user_id_id)');
    $this->addSql('COMMENT ON COLUMN code.expired_at IS \'(DC2Type:datetime_immutable)\'');
    $this->addSql('CREATE TABLE mark (user_id_id INT NOT NULL, anecdote_id_id INT NOT NULL, value INT NOT NULL, PRIMARY KEY(user_id_id, anecdote_id_id))');
    $this->addSql('CREATE INDEX IDX_6674F2719D86650F ON mark (user_id_id)');
    $this->addSql('CREATE INDEX IDX_6674F271A347EF68 ON mark (anecdote_id_id)');
    $this->addSql('CREATE TABLE "user" (id INT NOT NULL, surname VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, patronymic VARCHAR(255) DEFAULT NULL, email VARCHAR(255) NOT NULL, PRIMARY KEY(id))');
    $this->addSql('ALTER TABLE anecdote ADD CONSTRAINT FK_A5051EEC69CCBE9A FOREIGN KEY (author_id_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
    $this->addSql('ALTER TABLE code ADD CONSTRAINT FK_771530989D86650F FOREIGN KEY (user_id_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
    $this->addSql('ALTER TABLE mark ADD CONSTRAINT FK_6674F2719D86650F FOREIGN KEY (user_id_id) REFERENCES "user" (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
    $this->addSql('ALTER TABLE mark ADD CONSTRAINT FK_6674F271A347EF68 FOREIGN KEY (anecdote_id_id) REFERENCES anecdote (id) NOT DEFERRABLE INITIALLY IMMEDIATE');
}
\end{minted}

Таким образом, была создана схема базы данных.

\subsection{Создание базовых CRUD для Backend-приложения}
\subsubsection{Постановка задачи}
Построить CRUD (API) PHP-приложения на фреймворке Symfony для функционирования
Backend-приложения. 

\subsubsection{Необходимые понятия}

DTO (Data Transfer Object) — это объект, который используется для передачи 
данных между различными слоями приложения или между разными сервисами. DTO 
не содержит бизнес-логики, а лишь представляет структуру данных, которая 
упрощает и стандартизирует процесс передачи информации.

Основные задачи DTO:
\begin{enumerate}
    \item Стандартизация данных: DTO помогает определить строгую структуру 
    данных, передаваемых между слоями, что улучшает читаемость и поддержку кода.
    \item Изоляция внутренних структур: DTO защищает внутренние модели данных 
    от прямого взаимодействия с внешними системами, предотвращая возможные 
    утечки или модификации данных.
    \item Оптимизация передачи данных: DTO может содержать только необходимые 
    для передачи данные, что снижает объем передаваемой информации, особенно 
    важно при работе с REST API.
    \item Упрощение сериализации: DTO легко преобразовать в форматы передачи 
    данных, такие как JSON или XML, что удобно при обмене данными между 
    клиентом и сервером.
\end{enumerate}

Преимущества использования Symfony для REST API
\begin{enumerate}
    \item Автоматизация: Генерация кода упрощает создание API.
    \item Мощный ORM: Doctrine облегчает управление базой данных.
    \item API Platform: Symfony интегрируется с API Platform для создания 
    сложных API.
    \item Валидация: Простая интеграция с системой валидации данных.
    \item Гибкость: Легко добавлять middleware, авторизацию и другие механизмы.
\end{enumerate}

Symfony — это мощный PHP-фреймворк, который упрощает создание REST API.

REST (Representational State Transfer) — это архитектурный стиль для 
разработки распределённых систем, особенно веб-сервисов. Этот подход 
базируется на наборе принципов и ограничений, которые определяют, как 
системы взаимодействуют через интернет, используя стандартный протокол HTTP.

\begin{enumerate}
    \item Клиент-серверная архитектура.
    Клиент и сервер чётко разделены: клиент отвечает за интерфейс 
    пользователя, а сервер управляет данными и их обработкой. Это 
    разделение упрощает разработку и масштабирование системы.

    \item Отсутствие состояния (Stateless).
    Каждый запрос от клиента к серверу должен содержать всю необходимую 
    информацию для обработки. Сервер не сохраняет состояние сессии между 
    запросами, что упрощает его масштабирование.

    \item Кэширование.
    Ответы сервера могут быть помечены как кэшируемые или некэшируемые. 
    Это уменьшает нагрузку на сервер и повышает производительность, если 
    данные изменяются редко.

    \item Единообразие интерфейса (Uniform Interface).
    REST придерживается стандартизированного набора методов HTTP: GET, POST, 
    PUT, DELETE и др. Ресурсы идентифицируются через URI (Uniform Resource 
    Identifier), и операции над ними описываются этими методами.

    \item Многоуровневая система (Layered System).
    Компоненты могут быть распределены на нескольких уровнях (например, 
    прокси, серверы кэширования), что увеличивает надёжность и 
    масштабируемость системы.

    \item Представления ресурсов (Representations).
    Ресурсы передаются в формате представления: JSON, XML, HTML или других. 
    Это позволяет клиентам работать с данными независимо от внутреннего 
    устройства сервера.

    \item Код по требованию (Code-on-Demand) (опционально).
    Сервер может передавать исполняемый код (например, JavaScript) клиенту 
    для выполнения, что повышает гибкость клиентской части.
\end{enumerate}

Далее рассмотрим особенности модели MVC и для чего в ней требуется контроллер

MVC (Model-View-Controller) — это архитектурный шаблон проектирования, который 
используется для разделения логики приложения на три взаимосвязанных 
компонента: Model (модель), View (представление) и Controller (контроллер). 
Этот подход позволяет повысить модульность, читаемость и тестируемость кода, 
а также упростить его поддержку и масштабирование.

Компоненты MVC:
\begin{enumerate}
    \item Model (Модель)
    \begin{enumerate}
        \item Отвечает за управление данными приложения.
        \item Включает бизнес-логику, правила валидации данных и 
        взаимодействие с базой данных.
        \item Обеспечивает независимость от пользовательского интерфейса.    
    \end{enumerate}

    \item View (Представление)
    \begin{enumerate}
        \item Отвечает за отображение данных пользователю.
        \item Содержит пользовательский интерфейс (HTML, CSS, JavaScript в 
        веб-приложениях).
        \item Не содержит логики работы с данными, а только принимает их из 
        модели через контроллер.
    \end{enumerate}

    \item Controller (Контроллер)
    \begin{enumerate}
        \item Является посредником между моделью и представлением.
        \item Обрабатывает пользовательские запросы, вызывает соответствующие 
        методы модели и подготавливает данные для представления.
    \end{enumerate}    
\end{enumerate}
    
На что следует обратить внимание при внедрении MVC:
\begin{enumerate}
    \item Сложность для небольших проектов: для маленьких приложений 
    использование MVC может быть избыточным.
    \item Явное разделение кода: код каждой части должен строго 
    соответствовать своей ответственности, что требует внимательного 
    проектирования.
    \item Обратная связь между компонентами: контроллер соединяет модель и 
    представление, что позволяет избежать тесной зависимости между ними.
\end{enumerate}

MVC используется во многих современных фреймворках, в том числе и в
используемом в нашем случае фреймворке PHP — Symfony.

\subsubsection{Решение}

Для решения данной задачи требовалось:

\begin{enumerate}
    \item Создать DTO с помощью инструментов PHP-фреймворка Symfony
    \item Создать класс-контроллер для сущности Anecdote
    \item Создать бизнес-логику для указанных endpoint из вышеописанного
    контроллера
\end{enumerate}

Рассмотрим пример на одной из сущностей (анекдоте): остальные реализовались по
аналогичному сценарию.

Создание контроллера для сущности Anecdote с относительным URI 
\texttt{\/anecdote}, а также DTO для работы этого контроллера (обработки 
запросов и ответов) указано в приложении \ref{appendA}

В этом коде представлены основные операции с сущностью Anecdote: создание,
обновление, чтение, удаление. Это реализуется с помощью вызова у переменной
\texttt{\$anecdoteService} методов create, edit и прочих.

Сама же переменная \$anecdoteService является объектом класса
AnecdoteService, в котором хранится вся бизнес-логика методов, связанных с 
сущностью Anecdote. 

Рассмотрим один из методов: их логика достаточно тривиальна:

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
public function editAnecdote(Anecdote $anecdote, AnecdoteBaseRequestDTO $DTO): AnecdoteBaseResponseDTO
{
    if ($title = $DTO->title) {
        $anecdote->setTitle($title);
    }
    if ($text = $DTO->text) {
        $anecdote->setText($text);
    }
    if ($category = $DTO->category) {
        $anecdote->setCategory($category);
    }
    $this->entityManager->flush();
    return new AnecdoteBaseResponseDTO($anecdote);
}
\end{minted}

Таким образом, при последующем использовании кода были выявлены следующие
преимущества данного подхода к решению задачи: 

\begin{enumerate}
    \item DTO позволяет отделить внутренние модели приложения от структуры 
    данных, передаваемых клиенту, что упрощает форматирование ответов и 
    защиту чувствительных данных.
    \item Контроллеры обеспечивают чистую организацию кода, выступая 
    посредниками между бизнес-логикой и клиентами API, обрабатывая запросы, 
    вызовы сервисов и формирование ответов 
    \cite{rest_api_tutorial, microsoft_rest_api, aws_rest_api}.
\end{enumerate}

\subsection{Создание авторизации на основе концепции access- и refresh-токенов}
\subsubsection{Постановка задачи}
Создать механизм авторизации на языке PHP с помощью access- и refresh-токенов.

\subsubsection{access- и refresh-токены}

Использование access и refresh токенов — это подход для безопасной и 
удобной аутентификации пользователей, часто применяемый в системах с 
использованием JWT (JSON Web Tokens). Этот метод позволяет минимизировать 
риски, связанные с компрометацией токенов, и улучшить пользовательский опыт 
за счёт автоматического обновления сессии.

\textbf{Access-токен} — краткоживущий токен, содержащий информацию об 
аутентификации пользователя (например, ID, роли и права доступа). Используется 
для выполнения запросов к защищённым ресурсам API. Имеет короткий срок действия
(например, 15 минут), что снижает последствия его утечки.

\textbf{Refresh-токен} — долгоживущий токен, используемый только для получения 
нового access-токена. Не используется напрямую для доступа к API. Хранится в 
более защищённом месте (например, в HTTP-only cookies), чтобы минимизировать 
риск его утечки.

\textbf{Алгоритм работы системы}:

\begin{enumerate}
    \item Пользователь аутентифицируется (например, с помощью логина и пароля).
    \item Сервер выдаёт:
    \begin{enumerate}
        \item Access-токен для доступа к ресурсам API.
        \item Refresh-токен для продления действия сессии.
    \end{enumerate}
    \item Клиент отправляет access-токен в каждом запросе к API 
    (обычно в заголовке Authorization: Bearer <token>).
    \item Если access-токен истёк, клиент использует refresh-токен, 
    чтобы получить новый access-токен через специальный API-эндпоинт.
    \item Если refresh-токен истёк, пользователь должен пройти повторную 
    аутентификацию \cite{baeldung_tokens, auth0_refresh_tokens}.
\end{enumerate}

\subsubsection{Решение}

Для выполнения задачи требуется выполнить следующее:

\begin{enumerate}
    \item Создать сущность Device и добавить её в базу данных. Указать в
    ней два токена - access и refresh, у каждого своё время жизни.
    \item Реализовать проверку на время жизни токена в ApiAuthenticator.
    \item Реализовать метод обновления времени жизни access токена.
    \item Добавить функционал отправки письма на почту при регистрации
    с помощью MailerService
\end{enumerate}

Все эти шаги описаны в классе SecurityService, код которого содержится в 
приложении \ref{appendB}.

\subsection{Создание docker-compose файлов для настройки
    контейнеризации и автоматизации запуска приложения}
\subsubsection{Постановка задачи}
Создать автоматизацию контейнеризации с помощью docker и docker-compose
в .yaml файле.

\subsubsection{Docker и docker compose}

Docker — это технология контейнеризации, которая упрощает создание, 
развертывание и управление приложениями. Она позволяет упаковать приложение 
и его зависимости в изолированные контейнеры, которые могут быть запущены 
на любой платформе, поддерживающей Docker. 

Контейнеризация с использованием Docker отличается рядом особенностей, 
делающих её удобным инструментом для разработки, тестирования и 
развертывания приложений.

Преимущества Docker:
\begin{enumerate}
    \item Изоляция среды. Docker контейнеры изолируют приложения и их 
    зависимости, что позволяет избежать конфликтов с локальной средой 
    разработчика или сервером. Каждое приложение запускается в своей среде, 
    не влияя на другие.

    \item Универсальность и совместимость. Контейнеры гарантируют, что 
    приложение будет работать одинаково на любом хосте, где установлен 
    Docker (локальная машина, сервер, облако).

    \item Быстрое развертывание. Запуск контейнера занимает секунды, так как
     он использует легковесные образы, а не тяжелые виртуальные машины.

    \item Повторяемость. С использованием Dockerfile можно точно 
    задокументировать и воспроизвести среду разработки и продакшн.

    \item Легкость тестирования. Тестирование в изолированной среде Docker 
    помогает обнаружить проблемы, которые могут проявиться в реальном продакшне.

    \item Упрощенная миграция и масштабирование. Легко переносить приложение 
    между средами (локальная разработка, staging, production). Контейнеры 
    масштабируются горизонтально с помощью оркестрации (например, Kubernetes 
    или Docker Swarm).
\end{enumerate}
    

\subsubsection{Решение}

Контейнеризация с помощью Docker Compose позволяет легко управлять 
многокомпонентными приложениями, описывая их инфраструктуру (контейнеры, 
сети, тома) в одном файле docker-compose.yml. Это упрощает настройку, 
запуск и масштабирование, позволяя разработчикам и командам быстро 
развертывать целые приложения с зависимостями (например, серверы, 
базы данных) с помощью одной команды (docker-compose up).

Для решения напишем .yaml файл, который как раз будет контролировать запуск 
сервисов, описанных в docker compose.

\begin{minted}[linenos, breaklines=true, style=bw]{YAML}
version: '3.9'

services:
    nginx:
    build:
        context: ./build/nginx
        dockerfile: Dockerfile
    container_name: nginx-task3
    volumes:
        - ./app/public:/var/www/app/public/:ro
        - ./build/nginx/config:/etc/nginx/conf.d/:ro
    ports: 
        - 8080:80
    networks:
        - default
    
    db:
    image: postgres:15.2-alpine3.17
    container_name: db-task3
    environment:
        POSTGRES_PASSWORD: postgres
        POSTGRES_DB: db
        POSTGRES_USER": krab1o
        POSTGRES_HOST: krab1ocomp
    volumes:
        - db_volume:/var/lib/postgresql/data
    networks:
        - default

    php:
    build:
        context: ./build/php
        dockerfile: Dockerfile
    container_name: php-task3
    volumes:
        - ./app:/var/www/app
    networks:
        - default
networks:
    default:
volumes:
    db_volume:
\end{minted}

При этом docker-compose использует два кастомных Docker-образа, которые 
описаны ниже.

Здесь представлен Docker-файл для сервиса nginx:

\begin{minted}[linenos, breaklines=true, style=bw]{YAML}
FROM php:fpm-alpine3.20 as php_upstream
FROM composer/composer:2-bin

FROM php_upstream as php_base

WORKDIR /var/www/app

RUN apk update && apk upgrade && apk add php php-fpm

COPY --from=composer /usr/bin/composer /usr/bin/composer

EXPOSE 9000

CMD ["php-fpm"]
\end{minted}

А здесь — для сервиса backend PHP:

\begin{minted}[linenos, breaklines=true, style=bw]{YAML}
FROM nginx:stable-alpine

WORKDIR /var/www

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]    
\end{minted}

Таким образом, приложение на PHP с сервисом базы данных и сервером nginx,
который выполняет функцию reverse-proxy, поднимается с помощью docker compose,
а кастомные команды, которые требуется выполнить в образах сервера и 
backend-приложения, описаны в Dockerfile \cite{docker, docker_docs}.

\conclusion

В ходе выполнения данной работы были изучены современные инструменты и 
технологии для разработки серверной части веб-приложений. В частности, 
были рассмотрены особенности работы с языком PHP и фреймворком Symfony, 
а также разработана архитектура приложения на основе MVC. 

Настроено контейнеризированное окружение с использованием Docker и веб-сервера 
Nginx для обеспечения эффективной и стабильной работы приложения. Особое 
внимание уделялось тестированию RESTful API с помощью Postman и 
документированию его с использованием Swagger. Также проведен анализ 
преимуществ и недостатков применяемых технологий в контексте разработки 
масштабируемых и безопасных веб-приложений. 

Перспективы применения результатов данной работы достаточно широки. 

Во-первых, разработанное приложение может быть использовано как основа 
для дальнейшего развития и расширения функциональности, например, для 
добавления новых типов контента или внедрения системы рекомендаций на 
основе предпочтений пользователей. 

Во-вторых, контейнеризация с использованием Docker позволяет легко 
масштабировать приложение и развертывать его в различных окружениях, 
что важно для гибкости и мобильности современных веб-сервисов. 

Применение Nginx как веб-сервера повышает производительность и надежность 
работы приложения при обработке большого количества запросов, что открывает 
возможности для использования данного решения в высоконагруженных системах. 
Кроме того, навыки тестирования и документирования API с Postman и Swagger 
могут быть применены в разработке других проектов, требующих четкой и 
структурированной документации интерфейсов.

Таким образом, созданный проект достигнул поставленных задач школы ПрофСофт,
цель производственной практики была достигнута, а все поставленные в ходе
практики задачи решены.

\inputencoding{cp1251}
\bibliographystyle{gost780uv}
\bibliography{thesis.bib}
\inputencoding{utf8}

\appendix

\section{Создание контроллера и DTO для него}
\label{appendA}

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
#[Route(path: '/anecdote')]
class AnecdoteController extends AbstractController
{
    public function __construct(
        private readonly ValidatorService    $validator,
        private readonly SerializerInterface $serializer,
    ) { }
    #[Route(path: '', name: 'apiGetAnecdoteList', methods: Request::METHOD_GET)]
    public function getAnecdoteList(AnecdoteService $anecdoteService): JsonResponse
    {
        return $this->json(
            data: $anecdoteService->getAnecdoteList(),
            status: Response::HTTP_OK,
        );
    }
    #[Route(path: '', name: 'apiCreateAnecdote', methods: Request::METHOD_POST)]
    public function createUser(Request $request, AnecdoteService $anecdoteService): JsonResponse
    {
        $data = $this->serializer->deserialize($request->getContent(), AnecdoteBaseRequestDTO::class, 'json');
        $this->validator->validate(body: $data, groupsBody: ['register']);
        return $this->json(
            data: $anecdoteService->createAnecdote($data),
            status: Response::HTTP_CREATED,
        );
    }
    #[Route(path: '/{id<\d+>}', name: 'apiEditAnecdote', methods: Request::METHOD_PATCH)]
    public function editAnecdote(
        Anecdote        $id,
        Request         $request,
        AnecdoteService $anecdoteService,
    ): JsonResponse
    {
        $data = $this->serializer->deserialize($request->getContent(), AnecdoteBaseRequestDTO::class, 'json');
        $this->validator->validate(body: $data, groupsBody: ['edit']);

        return $this->json(
            data: $anecdoteService->editAnecdote($id, $data),
            status: Response::HTTP_CREATED,
        );
    }
    #[Route(path: '/{id<\d+>}', name: 'apiDeleteAnecdote', methods: Request::METHOD_DELETE)]
    public function deleteUser(Anecdote $id, AnecdoteService $anecdoteService): JsonResponse
    {
        $anecdoteService->deleteAnecdote($id);

        return $this->json(
            data: [],
            status: Response::HTTP_NO_CONTENT,
        );
    }
}
\end{minted}

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
class AnecdoteBaseRequestDTO
{
    public function __construct(
        #[Assert\NotNull(groups: ['register'])]
        #[Assert\Type(type: 'string', groups: ['register', 'edit'])]
        #[Assert\Length(max: 127, groups: ['register', 'edit'])]
        public ?string $title = null,

        #[Assert\NotNull(groups: ['register'])]
        #[Assert\Type(type: 'string', groups: ['register', 'edit'])]
        public ?string $text = null,

        #[Assert\NotNull(groups: ['register'])]
        #[Assert\Type(type: 'string', groups: ['register', 'edit'])]
        public ?bool $category = null,
    ) { }
}
\end{minted}

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
class AnecdoteBaseResponseDTO
{
    public int $id;
    public string $title;
    public string $text;
    public string $category;

    public function __construct(Anecdote $anecdote)
    {
        $this->id = $anecdote->getId();
        $this->title = $anecdote->getTitle();
        $this->text = $anecdote->getText();
        $this->category = $anecdote->getCategory();
    }
}
\end{minted}

\section{Создание авторизации}
\label{appendB}

\begin{minted}[linenos, breaklines=true, style=bw]{PHP}
class SecurityService
{
    private const string SUBJECT = 'Код авторизации';

    private const string ACCESS_TOKEN_LIFETIME = '+10 minutes';
    private const string REFRESH_TOKEN_LIFETIME = '+90 days';

    public function __construct(
        #[Autowire(service: YandexMailerService::class)]
        private MailerServiceInterface   $mailer,
        protected EntityManagerInterface $entityManager,
    ) { }
    public function sendCode(LoginDTO $DTO): void
    {
        $code = new Code();
        if (!$this->entityManager->getRepository(User::class)->
        findOneByEmail($DTO->email) instanceof User) {
            throw new ApiException(
                message: "Пользователь по указанному email не найден",
                status: Response::HTTP_NOT_FOUND,
            );
        }
        $code
            ->setEmail($DTO->email);

        $this->entityManager->persist($code);
        $this->entityManager->flush();
        $this->mailer->send(self::SUBJECT, $code->getCode(), (array)$DTO->email);
    }

    public function verifyCode(LoginDTO $DTO): array
    {
        $code = $this->entityManager->getRepository(Code::class)->
        findOneBy([
            'code' => $DTO->code,
            'email' => $DTO->email,
            'status' => CodeStatus::ACTIVE->value,
        ]);

        if (!$code instanceof Code) {
            throw new ApiException(
                'Неверный код авторизации',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }
        if ($code->getExpiredAt() < new \DateTime()) {
            $code
                ->setStatus(CodeStatus::EXPIRED->value);
            $this->entityManager->flush();
            throw new ApiException(
                'Код авторизации истек',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }
        $owner = $this->entityManager->getRepository(User::class)->
        findOneBy([
            'email' => $DTO->email,
        ]);

        $device = (new Device())
            ->setOwner($owner)
            ->setTokenExpiresAt((new \DateTime())->modify(self::ACCESS_TOKEN_LIFETIME))
            ->setRefreshTokenExpiresAt((new \DateTime())->modify(self::REFRESH_TOKEN_LIFETIME));
        
        $code
            ->setStatus(CodeStatus::INACTIVE->value);

        $this->entityManager->persist($device);
        $this->entityManager->flush();

        return [
            'token' => $device->getToken(),
            'refreshToken' => $device->getRefreshToken(),
        ];
    }
    public function logout(string $apikey): void
    {
        $device = $this->entityManager->getRepository(Device::class)->
        findOneBy([
            'apikey' => $apikey,
        ]);
        $device->setStatus(DeviceStatus::INACTIVE->value);
        $this->entityManager->flush();
    }
    public function refresh(?string $refreshToken): array {
        $device = $this->entityManager->getRepository(Device::class)->
        findOneBy([
            'refreshToken' => $refreshToken,
            'status' => DeviceStatus::ACTIVE->value,
        ]);

        if (!$device instanceof Device) {
            throw new ApiException(
                message: 'Некорректный refresh токен',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }

        if ($device->getRefreshTokenExpiresAt() < new \DateTime()) {
            $device->setStatus(DeviceStatus::EXPIRED->value);
            $this->entityManager->flush();

            throw new ApiException(
                message: 'Refresh токен истёк',
                status: Response::HTTP_UNAUTHORIZED,
            );
        }

        $device
            ->setToken($this->generateToken())
            ->setTokenExpiresAt((new \DateTime())->modify(self::ACCESS_TOKEN_LIFETIME))
            ->setRefreshToken($this->generateToken());

        $this->entityManager->flush();

        return [
            'token' => $device->getToken(),
            'refreshToken' => $device->getRefreshToken(),
        ];
    }
    public function generateToken(): string {
        return md5(random_int(100000, 999999) . microtime());
    }
}
\end{minted}

\end{document}
