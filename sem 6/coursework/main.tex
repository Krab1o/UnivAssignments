\documentclass[coursework]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафдры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% Включение шрифта
%    times      - включение шрифта Times New Roman (если установлен)
%                 по умолчанию выключен
\usepackage{preamble}
% \captionsetup[figure]{font= normalsize, labelfont=normalsize}
\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работ
\title{Разработка API web-приложения для организации
процесса уборки мусора}

% Курс
\course{3}

% Группа
\group{351}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
% \napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Устюшина Богдана Антоновича}

% Заведующий кафедрой 
\chtitle{доцент, к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
% \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{А.\,С.\,Иванов}

% Руководитель практики от организации (руководитель для цифровой кафедры)
\patitle{доцент, к.\,ф.-м.\,н.}
\paname{С.\,В.\,Миронов}

% Руководитель НИР
\nirtitle{доцент, к.\,п.\,н.} % степень, звание
\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2022}
\practFinish{13.01.2023}

% Год выполнения отчета
\date{2024}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
% \secNumbering

\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr

\sloppy

\intro

В современном мире проблема загрязнения окружающей среды становится всё более 
актуальной, и мусор, оставляемый на улицах, представляет собой одну из самых 
серьёзных составляющих этой проблемы. Накопление отходов в общественных местах 
не только нарушает эстетический облик городов, но и оказывает негативное 
воздействие на здоровье человека и окружающую экосистему. С каждым годом 
количество бытового и промышленного мусора растёт, и его присутствие на 
улицах городов становится всё более заметным. Это вызывает множество проблем, 
от ухудшения качества воздуха до разрушения экосистем и негативного влияния 
на биоразнообразие.

Мусор, оставляемый на улицах, становится источником различных заболеваний, так 
как разлагающиеся отходы выделяют вредные вещества в воздух и почву. 
Загрязнение воздуха, вызванное гниением мусора, может приводить к серьёзным 
проблемам со здоровьем, таким как аллергические реакции и респираторные 
заболевания. Кроме того, скопление мусора привлекает животных и насекомых, 
что может стать причиной распространения инфекционных заболеваний. Каждый 
элемент уличного мусора, будь то пластиковая бутылка, упаковка или другие 
отходы, способен оказать разрушительное влияние на окружающую среду, нарушая 
естественные экосистемные процессы и угрожая существованию многих видов 
растений и животных.

Ситуация с утилизацией мусора на улицах становится всё более серьёзной. 
Местные власти часто не успевают оперативно реагировать на проблемы, связанные 
с накоплением отходов, из-за нехватки ресурсов и информации о местах их 
скопления. В то же время, население не всегда осведомлено о правильных 
способах утилизации мусора и необходимости поддержания чистоты в своём 
окружении. Поэтому крайне важно не только повышать уровень экологической 
осведомлённости граждан, но и предоставлять им удобные инструменты для 
сообщения о проблемах, связанных с мусором на улицах.

Современные технологии, особенно мобильные приложения, могут стать важным 
инструментом в борьбе с проблемой мусора на улицах. Мобильные платформы 
позволяют быстро и эффективно информировать местные власти о проблемах с 
загрязнением, а также организовывать взаимодействие между гражданами и 
ответственными службами. В рамках своей курсовой работы я разрабатываю 
приложение, которое позволит жителям оперативно сообщать о местах, где 
скопился мусор на улицах, и помогать ответственным службам быстрее устранять 
эти нарушения.

Моё приложение станет платформой для гражданского взаимодействия, где каждый 
пользователь сможет внести свой вклад в улучшение чистоты в своём городе. 
Пользователи смогут легко отправлять сообщения о местах накопления мусора, 
включая фотографии и описание проблемы. Это даст возможность ответственным 
службам более оперативно реагировать на обращения граждан и принимать меры по 
устранению мусора.

Такой подход позволит создать активное сообщество, заинтересованное в 
поддержании чистоты на улицах. Приложение будет не только инструментом для 
сообщения о проблемах, но и средством повышения осведомлённости населения о 
важности заботы о чистоте окружающей среды. Я надеюсь, что благодаря таким 
инициативам мы сможем привлечь внимание к проблеме мусора на улицах и внести 
реальный вклад в её решение, создавая чистую и здоровую среду для будущих 
поколений.

Целью работы является разработка API веб-приложения для эффективной организации
процесса нахождения и уборки мусора на улицах города.

Для достижения цели необходимо решить следующие задачи:
\begin{enumerate}
    \item Рассмотреть используемые технологии, описать преимущества выбранного 
    стека
    \item Описать архитектуру и структуру построенной информационной системы, 
    backend- и database-сервисов
    \item Реализовать это с помощью выбранных инструментов
\end{enumerate}

\section{Обзор используемых технологий}

При разработке современных веб-приложений крайне важно выбирать
надёжные и производительные технологии, которые обеспечат 
масштабируемость, гибкость и лёгкость в обслуживании проекта. 
В своём проекте я использую FastAPI, Alembic, PostgreSQL и Docker. У 
каждой из этих технологий есть важные преимущества, которые делают 
их идеальными для создания стабильных и эффективных систем. 
Рассмотрим более подробно, почему стоит выбрать эти инструменты 
для разработки.

\subsection{FastAPI}

FastAPI — это современный и высокопроизводительный веб-фреймворк
для создания API на языке Python. Его основными преимуществами 
являются скорость, лёгкость в использовании и поддержка асинхронного 
программирования.

FastAPI был разработан с акцентом на высокую производительность
и быстрый отклик. Благодаря использованию асинхронных возможностей 
Python (например, ASGI), он позволяет создавать приложения, 
которые могут обрабатывать множество запросов одновременно, 
что особенно важно для высоконагруженных систем. FastAPI по 
скорости сопоставим с такими популярными фреймворками, 
как Node.js и Go.

Ещё одним из достоинств FastAPI является интуитивно понятный
синтаксис и высокая автоматизация процессов. Фреймворк активно 
использует аннотации типов Python, что позволяет разработчикам 
легко описывать API и генерировать документацию в реальном времени. 
При этом FastAPI автоматически проверяет данные на соответствие 
типам, что существенно снижает количество ошибок и делает код более надёжным.

Также FastAPI генерирует документацию API автоматически с
использованием OpenAPI и Swagger, что очень полезно для 
разработки и тестирования приложений. Документация доступна 
в интерактивном виде и позволяет разработчикам и тестировщикам 
мгновенно видеть, как работает API, а также тестировать его 
функциональность.

Поддержка асинхронного программирования в FastAPI позволяет значительно
ускорить обработку запросов и уменьшить задержки в работе приложения. 
Это особенно полезно для задач, связанных с запросами к базе данных 
или внешним сервисам, где приложение может не блокироваться на время 
выполнения операций.

Несмотря на свою молодость, FastAPI активно развивается и поддерживается
сообществом разработчиков. Для него уже существуют многочисленные 
библиотеки и плагины, что позволяет легко расширять функциональность 
приложения \cite{fastapi,uvicorn}.


\subsection{Alembic}

Alembic — это инструмент для управления миграциями базы данных,
который используется совместно с SQLAlchemy, одним из самых 
популярных ORM-фреймворков для Python. Он играет важную роль в 
управлении версионностью схемы базы данных, особенно в проектах, 
где структура данных постоянно изменяется.

Alembic позволяет легко управлять изменениями в базе данных,
обеспечивая поддержку версионного контроля для схем. Это очень 
важно в процессе разработки, когда структура базы данных может 
изменяться, и необходимо сохранять синхронизацию между кодом 
приложения и его данными.

Alembic умеет автоматически создавать миграции на основе изменений 
в моделях SQLAlchemy. Это существенно упрощает процесс разработки
и снижает вероятность ошибок при ручной настройке схемы базы данных. 
Автоматическая генерация миграций ускоряет рабочий процесс и 
делает его более надёжным.

Одним из важных аспектов управления базами данных является возможность
отката изменений. Alembic предоставляет инструменты для того, чтобы 
откатывать миграции, если внесённые изменения привели к ошибкам 
или некорректным результатам. Это делает процесс обновления базы 
данных более безопасным.

Alembic легко интегрируется с SQLAlchemy, что делает его естественным 
выбором при работе с FastAPI. Эта комбинация позволяет разработчикам 
не только легко создавать и управлять моделями данных, но и оперативно 
вносить изменения в структуру базы данных, сохраняя её 
целостность \cite{alembic,sqlalchemy}.

\subsection{PostgreSQL}

PostgreSQL — это мощная объектно-реляционная система управления 
базами данных (СУБД), которая на протяжении многих лет остаётся 
одним из лидеров среди open-source решений для работы с данными. 
В своём проекте я использую PostgreSQL, и на это есть несколько причин:

PostgreSQL славится своей надёжностью и стабильностью.
Она предоставляет высокую степень защиты данных и обеспечивает 
устойчивость к сбоям, что делает её идеальной для критически 
важных приложений, требующих максимальной сохранности информации.

PostgreSQL отлично масштабируется и поддерживает работу с большими
объёмами данных. Это важное преимущество для приложений, 
которые планируются к расширению в будущем, или для тех, кто 
работает с массивами данных в реальном времени.

В отличие от некоторых других реляционных СУБД, PostgreSQL
поддерживает не только стандартные реляционные структуры данных, 
но и работу с JSON, геоданнымиЮ, используя технологию PostGIS 
и другими сложными типамиданных. Это делает её особенно полезной 
для приложений, которые требуют гибкости в работе с 
разнообразными структурами данных.

PostgreSQL полностью соответствует стандартам SQL, что делает 
её совместимой с большим количеством других систем и инструментов. 
Это позволяет использовать её в самых разных проектах и легко 
переносить на неё существующие базы данных.

PostgreSQL обеспечивает полную поддержку транзакций, что гарантирует 
целостность данных и их сохранность в случае сбоев. Это особенно 
важно для приложений, работающих с финансовыми данными или 
другими критически важными ресурсами.

PostgreSQL является бесплатной и открытой СУБД с огромным
сообществом разработчиков и пользователей. Это не только 
экономически выгодно, но и позволяет гибко настраивать систему 
под конкретные нужды проекта \cite{postgresql}.

\subsection{Docker}

Docker — это платформа для автоматизации развёртывания приложений 
в контейнерах. Контейнеризация позволяет упаковать приложение и 
все его зависимости в единый контейнер, что гарантирует его работу 
в любой среде. Docker стал неотъемлемой частью современных процессов 
разработки и развертывания благодаря своим многочисленным преимуществам.

Одним из ключевых преимуществ Docker является возможность создания 
изолированных контейнеров, в которых выполняется приложение. 
Это означает, что разработчик может быть уверен, что приложение 
будет работать одинаково на любой машине, независимо от её операционной 
системы и установленных зависимостей. Изоляция помогает избежать 
проблем, связанных с несовместимостью версий библиотек или конфигураций 
операционной системы.
    
Docker-контейнеры представляют собой лёгкие и переносимые единицы, 
которые можно запускать на любом сервере или облачном провайдере, 
поддерживающем Docker. Это делает приложение независимым от 
инфраструктуры, на которой оно работает, и упрощает перенос с локального 
окружения на серверное. При необходимости легко масштабировать 
приложение, запуская несколько контейнеров на разных узлах.
    
Docker идеально подходит для масштабирования микросервисов и 
распределённых систем. Контейнеры можно легко запускать параллельно, 
что позволяет масштабировать отдельные компоненты приложения в 
зависимости от нагрузки. Это также упрощает поддержку высокой 
доступности и балансировки нагрузки.
    
В отличие от виртуальных машин, которые требуют отдельного ядра 
операционной системы для каждого экземпляра, Docker использует 
ресурсы хоста, что делает контейнеры более лёгкими и менее 
ресурсоёмкими. Это позволяет запускать большее количество контейнеров 
на одном сервере по сравнению с виртуальными машинами.
    
Docker позволяет быстро разворачивать контейнеры, что значительно ускоряет 
процесс деплоя. Контейнеры можно легко обновлять, создавать новые версии 
образов и откатываться к предыдущим версиям при необходимости. Это даёт 
разработчикам и администраторам системы гибкость в управлении версиями 
приложения.
    
Docker позволяет описывать инфраструктуру через Dockerfile, где подробно 
указываются все этапы сборки образа, включая установку зависимостей, 
конфигурацию среды и подготовку приложения к запуску. Это даёт возможность 
легко автоматизировать процесс сборки и развертывания, делая его 
воспроизводимым.
    
Docker имеет огромное сообщество и развивающуюся экосистему. Существует 
множество готовых к использованию контейнеров в Docker Hub, что позволяет 
значительно ускорить процесс разработки за счёт использования существующих 
решений, таких как базы данных, кэш-системы, и другие сервисы.

\subsection{Docker Compose}

В дополнение к Docker я также использую Docker Compose. Docker Compose — это 
инструмент для управления многоконтейнерными приложениями, который изначально
являлся дополнением к контейнерной экосистеме Docker.

Docker Compose позволяет определять и запускать несколько контейнеров Docker 
как единое приложение, что упрощает настройку, управление и масштабирование 
сложных систем. Docker Compose использует файл конфигурации YAML для описания 
всех сервисов, их зависимостей, сетей и томов, необходимых для корректной 
работы приложения.

Docker Compose даёт возможность запускать одновременно несколько контейнеров, 
которые взаимодействуют друг с другом. Например, в рамках одного проекта могут 
быть контейнеры для веб-сервера, базы данных, кеширования и других сервисов. 
Это особенно полезно для микросервисной архитектуры, где каждое приложение 
состоит из множества взаимосвязанных компонентов.
    
Docker Compose использует понятный файл конфигурации 
\texttt{docker-compose.yml}, где описываются все сервисы, их зависимости и 
параметры запуска. Это позволяет легко управлять сложной инфраструктурой и 
делиться конфигурацией с другими разработчиками. Кроме того, этот файл делает 
инфраструктуру воспроизводимой: любой разработчик может развернуть такую же 
среду у себя локально, используя один и тот же конфигурационный файл.
    
Compose значительно упрощает разработку и тестирование многосоставных 
приложений. С его помощью можно настроить различные окружения (например, 
тестовые и продакшн) с минимальными усилиями. Разработчики могут быстро 
развернуть все необходимые компоненты в контейнерах, не настраивая вручную 
каждую службу.
    
Docker Compose упрощает работу с сетями, что важно для взаимодействия между 
контейнерами. Каждый сервис может находиться в отдельной сети или общаться с 
другими сервисами через виртуальные сети Docker. Это позволяет создавать 
изолированные окружения для разных частей приложения и управлять доступом 
между ними. Кроме того, Docker Compose позволяет настраивать постоянные тома 
для хранения данных, что критически важно для баз данных и других сервисов, 
требующих сохранения состояния.
    
Docker Compose позволяет легко масштабировать приложение, увеличивая 
количество реплик определённых контейнеров. Например, если веб-сервер начинает 
испытывать высокую нагрузку, его можно масштабировать до нескольких экземпляров 
без необходимости изменения конфигурации всего проекта. Это делает 
Docker Compose отличным инструментом для управления как разработкой, так и 
продакшн-средами.
    
Docker Compose может быть легко интегрирован в конвейеры непрерывной 
интеграции и доставки (CI/CD), что делает его полезным не только для 
локальной разработки, но и для автоматизированного развертывания приложений. 
С его помощью можно легко тестировать приложение в среде, максимально 
приближённой к продакшн.
    
Одно из важнейших преимуществ Docker Compose — это возможность запускать весь 
проект одной командой: \texttt{docker-compose up}. Все необходимые контейнеры 
будут автоматически развернуты и запущены, что значительно ускоряет и упрощает 
процесс настройки окружения, особенно для новых разработчиков или тестировщиков.
    
Docker Compose предоставляет удобные инструменты для мониторинга состояния 
контейнеров, их логов и работы в целом. Это упрощает отладку приложений и 
позволяет своевременно находить и устранять возможные проблемы \cite{docker}.

\subsection{Postman}

Postman — это популярный инструмент для разработки, тестирования и 
документирования API, который предоставляет разработчикам удобную среду для 
взаимодействия с сервером. В контексте разработки веб-приложений и API на 
основе FastAPI, PostgreSQL и Docker, использование Postman значительно упрощает 
процесс работы с сервером и помогает повысить качество разработки.

Одно из ключевых преимуществ Postman — это его интуитивно понятный интерфейс, 
который позволяет легко отправлять HTTP-запросы (GET, POST, PUT, DELETE) и 
получать ответы от сервера. При создании приложения с серверной частью, 
тестирование API может быть сложным и занимать много времени, если 
использовать стандартные средства, такие как cURL или встроенные в браузеры 
инструменты разработчика. 

Postman позволяет легко работать с различными методами API, не углубляясь в 
сложности написания запросов вручную. Для каждой точки доступа можно задать 
параметры запроса, тело и заголовки, что позволяет полноценно симулировать 
реальное использование API конечными пользователями. Это особенно полезно для 
проверки маршрутов аутентификации, регистрации, создания заявок и других 
функций, реализованных в приложении \cite{postman}.

\subsection{DBeaver}

Также в своей работе я использовал DBeaver — мощный инструмент для работы с 
реляционными и нереляционными базами данных, который предоставляет удобный 
графический интерфейс для взаимодействия с различными системами управления 
базами данных (СУБД).

Одним из значимых преимуществ DBeaver является возможность визуализации 
структуры базы данных. Инструмент позволяет наглядно отображать связи между 
таблицами, показывать диаграммы зависимостей и структуры данных. 
Это помогает лучше понять архитектуру базы данных, увидеть взаимосвязи между 
сущностями и эффективно планировать дальнейшую работу с данными.

DBeaver позволяет строить диаграммы ERD (Entity-Relationship Diagram), что 
помогает документировать структуру базы данных и делать её более понятной. 
DBeaver также поддерживает инструменты для создания резервных копий баз данных 
и выполнения миграций. Это особенно полезно в контексте разработки, когда 
нужно переносить данные или структуру базы данных с одного окружения на 
другое (или в контейнер) \cite{dbeaver}.

\section{Сценарий использования}

Для того чтобы понять, почему была выбрана данная архитектура базы данных, 
обратимся к User-story пользователя, которая покажет основную последовательность
событий, происходящих в процессе пользования приложением.

Основные сценарии использования приложения
\begin{enumerate}
    \item Создание заявки
    \item Модерация
    \item Принятие заявки
    \item Закрытие заявки
\end{enumerate}

Опишем их более подробно.

\subsection{Регистрация пользователя}

Прежде чем воспользоваться функционалом приложения, пользователю необходимо 
пройти регистрацию. Этот процесс включает в себя создание аккаунта с указанием 
имени пользователя, электронной почты и пароля. 

Регистрация необходима для того, чтобы обеспечить пользователям возможность 
создания заявок, а также контроля за своими действиями, участия в уборке 
территорий и прочим взаимодействии с другими участниками процесса.

\subsection{Создание события (заявки)}

После регистрации и входа в приложение пользователь может создать событие, 
которое представляет собой заявку на уборку мусора. Пользователь может 
указать все необходимые данные проблемы: описание, точный адрес 
места, а также географические координаты (при помощи GPS или карты). 

После ввода всех данных пользователь отправляет заявку, которая сохраняется 
в базе данных приложения и становится доступной для модерации. Таким образом, 
каждый пользователь может легко и оперативно заявить о мусоре, который 
скопился на улице, и инициировать его уборку. 

\subsection{Модерация заявки}

Для обеспечения достоверности информации все созданные пользователями заявки 
проходят этап модерации. Модераторы приложения проверяют, соответствует ли 
указанная информация действительности, и корректно ли описано место 
загрязнения. Это позволяет избежать возможных ошибок или дублирования заявок. 
После проверки заявка либо подтверждается и становится видимой для 
всех пользователей приложения, либо отклоняется, если выявлены несоответствия.

\subsection{Просмотр и выбор заявки пользователями}

После подтверждения заявки модератором, она появляется в общем списке активных 
заявок на уборку. Пользователи приложения могут просматривать эти заявки 
как в виде списка, так и на карте, где все места загрязнений будут отмечены 
специальными метками. В этом интерфейсе каждый пользователь может выбрать ту 
заявку, которая ему удобна по расположению или времени проведения уборки. 
После выбора заявки пользователь может принять её для выполнения. Это 
означает, что он берёт на себя ответственность за уборку данного участка, 
и статус заявки меняется на «Принята». Таким образом, другие пользователи 
видят, что заявка уже находится в процессе выполнения, и могут либо 
присоединиться, либо выбрать другую заявку.

\subsection{Выполнение уборки и закрытие заявки}

Когда пользователь принимает заявку на выполнение, он отправляется на место 
для проведения уборки. После завершения уборки он загружает в приложение 
фотографии, подтверждающие выполнение работы, и отправляет их на проверку 
модератору. Эти фотографии являются доказательством того, что мусор был 
убран, и заявка может быть закрыта. После загрузки фотографий пользователь 
нажимает кнопку «Заявка выполнена», и статус заявки изменяется на «Завершена».
Модератор проверяет предоставленные материалы, и если всё в порядке, заявка 
окончательно закрывается и исчезает из списка активных задач.

\section{Архитектура приложения}

Архитектура приложения, построенного с использованием FastAPI 
и SQLAlchemy, представляет собой современный и популярный 
подход к созданию веб-приложений на Python. Это приложение 
может быть ориентировано на создание и управление RESTful 
API, что делает его подходящим для широкого спектра задач, 
от небольших сервисов до масштабных систем.

Данное приложение использует FastAPI в качестве веб-фреймворка, 
а SQLAlchemy в связке с Alembic — для управления базой данных 
и миграциями. FastAPI является относительно новым веб-фреймворком, 
отличающимся своей скоростью и удобством работы благодаря 
полной поддержке асинхронности и валидации данных на уровне 
запросов с помощью Pydantic. В то же время SQLAlchemy — это 
ORM (Object-Relational Mapping) система, позволяющая работать с базой 
данных на уровне Python-объектов \cite{restapi}.

\subsection{Архитектуры базы данных}

\begin{figure}[H]
	\center{\includegraphics[scale=0.65]{./src/database.png}}
	\caption{Структура проекта}
	\label{pic1}
\end{figure}

На данном скриншоте представлена ER-диаграмма создаваемого сервиса. Основные
сущности приложения, как видно, это Users (пользователи) и TrashEvent (сбор 
мусора). 

Также с помощью отношения many-to-many была реализована ролевая система, 
которая позволяет администратору модерировать создаваемые пользователями заявки.

В таблице TrashStatus, как и было сказано выше, будет описано 4 стадии события.

\subsection{Архитектура backend-сервиса}

Рассмотрим структуру проекта.

\begin{figure}[H]
	\center{\includegraphics[scale=1.3]{./src/structure.png}}
	\caption{Структура проекта}
	\label{pic2}
\end{figure}

На данном скриншоте представлена основная структура проекта.

Далее опишем файлы в подробности, останавливаясь на самых важных деталях 
реализации.

\subsubsection{Аутентификация}

В файле \texttt{auth.py} реализованы функции для управления аутентификацией 
пользователей. Он использует библиотеку Passlib для хеширования паролей и 
Jose для работы с JSON Web Tokens (JWT) \cite{jwt,oauth2}. Основные функции включают:

\begin{enumerate}
    \item Хеширование пароля (\texttt{get\_password\_hash}) для 
    безопасного хранения паролей в базе данных.
    \item Проверка пароля (\texttt{verify\_password}) для аутентификации 
    пользователей.
    \item Создание токена доступа (\texttt{create\_access\_token}), который 
    выдается после успешной аутентификации и используется для последующих 
    запросов.
\end{enumerate}
    
\subsubsection{База данных}

Файл \texttt{database.py} отвечает за конфигурацию подключения к базе данных 
PostgreSQL. Здесь используется SQLAlchemy для создания движка базы данных, сессий и 
базового класса моделей:
\begin{enumerate}
    \item Создание движка (\texttt{create\_engine}) для работы с PostgreSQL.
    \item Сессии (\texttt{sessionmaker}) для управления транзакциями.
    \item Функция \texttt{get\_db}, которая создает и закрывает сессии базы 
    данных, что позволяет удобно управлять соединениями.
\end{enumerate}

\subsubsection{Основной файл приложения}

В файле \texttt{main.py} создается экземпляр приложения FastAPI и включаются 
маршруты, 
определенные в других модулях. Здесь также вызывается метод для создания всех 
таблиц в базе данных на основе моделей. Это обеспечивает готовность базы 
данных к работе сразу после запуска приложения.

\subsubsection{Модели данных}

Файл \texttt{models.py} определяет модели SQLAlchemy для пользователей и заявок:
\begin{enumerate}
    \item Модель \textbf{User} описывает пользователей с полями, такими как 
    username, email и hashed\_password. Также установлены связи с 
    моделью Request, что позволяет отслеживать заявки, созданные пользователем.
    \item Модель \textbf{TrashEvent} включает такие поля, как description, 
    address, latitude, longitude, status и временные метки. Она также имеет 
    связи с пользователями, которые создали и приняли заявки.
\end{enumerate}
    
\subsubsection{Схемы данных}

В файле \texttt{schemas.py} определены Pydantic схемы, которые используются для 
валидации входящих и исходящих данных. Это позволяет обеспечить целостность 
данных и простоту работы с ними.

Схемы \textbf{UserCreate}, \textbf{UserOut}, \textbf{TrashEventCreate}, и 
\textbf{TrashEventOut} описывают структуру данных, которые приложение ожидает 
получать и отправлять. Это упрощает работу с данными в API и гарантирует, 
что они соответствуют заданной структуре.

\subsubsection{Маршруты}

Файлы маршрутов управляют API-запросами и определяют доступные эндпоинты:
\begin{enumerate}
    \item В \texttt{router.py} реализована аутентификация пользователей с 
    маршрутом для регистрации и логина. Все данные аутентификации 
    обрабатываются через зависимости FastAPI, что упрощает управление токенами.
    \item В \texttt{events.py} находятся маршруты для создания, получения и 
    управления заявками. Это включает:
    \begin{itemize}
        \item Создание новых заявок.
        \item Получение доступных заявок, заявок текущего пользователя и 
        принятых заявок.
        \item Обновление статуса заявок (прием и завершение).
    \end{itemize}
    \item В \texttt{users.py} находятся маршруты для создания, получения и 
    управления заявками. Это включает:
    \begin{itemize}
        \item Получение всех пользователей и текущего пользователя
        \item Изменение данных для пользователя
        \item Удаление пользователя
    \end{itemize}
        
\end{enumerate}
    
\subsubsection{Миграции с использованием Alembic}

Файл \texttt{env.py} является конфигурацией для Alembic, инструмента миграции 
баз данных для SQLAlchemy. Он обеспечивает:
\begin{enumerate}
    \item Подключение к базе данных и управление миграциями.
    \item Автоматическую генерацию миграций на основе изменений в моделях, что 
    позволяет управлять схемой базы данных без потери данных.
\end{enumerate}

В остальном же, в директории \texttt{alembic} находятся файлы, отвечающий за
правильную работу СУБД и работу с миграциями.
    
\subsection{Контейнеризация с помощью Docker и Docker compose}

Опишем более детально процесс контейнеризации, который создан для деплоя 
приложения на любом устройстве.

\subsubsection{Использование базового образа}

\begin{minted}[linenos, breaklines=true, style=bw]{dockerfile}
    FROM python:3.11-slim
\end{minted}

Это минималистичный образ Python, который позволяет создать легковесное 
приложение с низким использованием ресурсов.

\subsubsection{Перенос файлов и зависимостей}

\begin{minted}[linenos, breaklines=true, style=bw]{dockerfile}
    WORKDIR /app
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    COPY . .
\end{minted}

Здесь мы устанавливаем рабочую директорию и копируем файл requirements.txt, 
который содержит все необходимые зависимости, в контейнер. Использование флага 
--no-cache-dir помогает уменьшить размер образа, исключая кешированные файлы.

Затем в образ копируется рабочий код, что делает все файлы доступными для 
выполнения.

\subsubsection{Инициализация базы данных}

\begin{minted}[linenos, breaklines=true, style=bw]{dockerfile}
    COPY init.sql /docker-entrypoint-initdb.d/
\end{minted}

Здесь мы копируем SQL-скрипт, который будет автоматически выполнен при 
инициализации базы данных PostgreSQL в контейнере. Этот скрипт создает 
пользователя и базу данных, если они еще не существуют.

\subsubsection{Открытие порта и запуск приложения}

\begin{minted}[linenos, breaklines=true, style=bw]{dockerfile}
    EXPOSE 8000
    CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
\end{minted}

Команда \texttt{EXPOSE} указывает, что приложение будет доступно на порту 
8000 внутри, сети Docker, а CMD запускает сервер Uvicorn, который обрабатывает 
входящие запросы.

\subsubsection{Docker Compose}

В \texttt{docker-compose.yml} файле указаны три сервиса, которые отвечают за
работу всего приложения. Это:
\begin{enumerate}
    \item \texttt{web}, образ которого собирается из Dockerfile, описанного 
    выше, а затем монтирует папку для поддержки hot-reload
    \item \texttt{db}, который не дополняется build-файлом и который создаёт
    volume для сохранения данных на локальную машину
    \item \texttt{alembic} — необязательный сервис, который автоматически
    запускает миграции в запущенных контейнерах
\end{enumerate}

\section{Реализация приложения}

Рассмотрим несколько примеров запросов, которые были сделаны к приложению.

\subsection{Регистрация}

В запросе для регистрации, согласно документации, требуется указать перечень
всех параметров, которые используются в DTO (Data-transfer object). В нашем
случае, JSON-запрос на сервер выглядел вот так:

\begin{figure}[H]
	\center{\includegraphics[scale=1]{./src/postman_reg.png}}
	\caption{Запрос на регистрацию пользователя}
	\label{pic3}
\end{figure}

После регистрации ещё нескольких пользователей, база данных выглядит вот так:

\begin{figure}[H]
	\center{\includegraphics[scale=0.46]{./src/dbeaver_res.png}}
	\caption{Состояние базы после регистрации трёх пользователей}
	\label{pic4}
\end{figure}

\subsection{Логин}

Попробуем залогиниться с помощью логина и пароля от учетной записи 
администратора:

\begin{figure}[H]
	\center{\includegraphics[scale=0.5]{./src/postman_login.png}}
	\caption{Запрос на логин пользователей}
	\label{pic5}
\end{figure}

Видим, что сервер выдаёт JWT-access токен для дальнейшего использования других
эндпоинтов.

\subsection{Работа с пользователями}

По GET-запросу, адрес которого видно на скриншоте, получаем следующие 
результаты:

\begin{figure}[H]
	\center{\includegraphics[scale=0.5]{./src/postman_get_users.png}}
	\caption{Запрос на получение всех пользователей}
	\label{pic6}
\end{figure}

Попытаемся поменять значения пользователя. Для этого отправим PUT-запрос с
целью изменить данные (в URL указываем ID пользователя, данные которого
хотим изменить): 

\begin{figure}[H]
	\center{\includegraphics[scale=1.2]{./src/postman_put_user.png}}
	\caption{Запрос на изменение данных пользователя}
	\label{pic7}
\end{figure}

Попытаемся удалить пользователя:

\begin{figure}[H]
	\center{\includegraphics[scale=0.7]{./src/postman_delete_user.png}}
	\caption{Запрос на удаление пользователя}
	\label{pic8}
\end{figure}

\begin{figure}[H]
	\center{\includegraphics[scale=0.45]{./src/dbeaver_deleted.png}}
	\caption{Состояние базы после удаления пользователя}
	\label{pic9}
\end{figure}

\conclusion

В ходе выполнения данной курсовой работы были выполнены следующие задачи:
\begin{enumerate}
    \item Рассмотреть технологии, описать преимущества выбранного стека
    \item Описать архитектуру и структуру построенной информационной системы
    \item Разработать веб-приложение 
\end{enumerate}

Таким образом, все поставленные задачи были выполнены.

Разработанное приложение представляет собой важный шаг в борьбе 
с загрязнением городской среды, объединяя усилия жителей для решения этой 
актуальной проблемы. Будущее данного проекта предполагает дальнейшее развитие 
функционала, включая: 

\begin{enumerate}
    \item Создание мобильного и десктопного веб-клиентов
    \item Интеграцию с внешними сервисами (например, YandexMaps для обозначения
    на карте событий)
    \item Возможность расширения на другие города 
\end{enumerate}

Приложение имеет потенциал для увеличения осведомлённости населения о 
проблемах экологии и вовлечения граждан в активные действия по улучшению 
своей окружающей среды.

\nocite{*}

\inputencoding{cp1251}
\bibliographystyle{gost780uv}
\bibliography{thesis.bib}
\inputencoding{utf8}

\appendix

\section{Исходный код основных файлов, которые отвечают за работу приложения}
\label{appendA}

\begin{center}
\textbf{backend/app/auth.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from . import models
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from .database import get_db

SECRET_KEY = "secret_key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/login")

def get_password_hash(password: str):
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str):
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=401,
        detail="Невалидные учетные данные",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        login: str = payload.get("sub")
        if login is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(models.User).filter(models.User.login == login).first()
    if user is None:
        raise credentials_exception
    return user
\end{minted}

\begin{center}
\textbf{backend/app/database.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
# app/database.py

from sqlalchemy import create_engine, MetaData
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql://meebin_user:password@db/meebin_db"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
metadata = MetaData()
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
\end{minted}

\begin{center}
\textbf{backend/app/main.py}
\end{center}
    
\begin{minted}[linenos, breaklines=true, style=bw]{python}
# app/main.py

from fastapi import FastAPI
from . import models, database
from .router import main_router

app = FastAPI()

# Создаем все таблицы
models.Base.metadata.create_all(bind=database.engine)

app.include_router(main_router, prefix="/api")
\end{minted}

\begin{center}
\textbf{backend/app/models.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
from sqlalchemy import Column, Integer, String, BigInteger, ForeignKey, Float, TIMESTAMP
from sqlalchemy.orm import relationship
from .database import Base

class User(Base):
    __tablename__ = "Users"

    id = Column(Integer, primary_key=True, index=True, unique=True)
    login = Column(String(50), nullable=False)
    mail = Column(String(80), nullable=False)
    password = Column(String(255), nullable=False)
    name = Column(String(60), nullable=False)
    lastname = Column(String(60), nullable=False)
    surname = Column(String(60), nullable=True)
    birthdate = Column(TIMESTAMP, nullable=False, default='-1')
    report_counter = Column(BigInteger, default=0, nullable=False)
    utilized_counter = Column(BigInteger, default=0, nullable=False)
    rating = Column(Float, nullable=True)
    city = Column(String(60), nullable=False)

    roles = relationship("Role", secondary="Users_Roles", back_populates="users")
    called_events = relationship("TrashEvent", foreign_keys="[TrashEvent.caller_id]", back_populates="caller")
    utilized_events = relationship("TrashEvent", foreign_keys="[TrashEvent.utilizator_id]", back_populates="utilizator")


class TrashEvent(Base):
    __tablename__ = "TrashEvent"

    id = Column(Integer, primary_key=True, index=True, unique=True)
    photo_url = Column(String(100), nullable=False)
    address = Column(String(255), nullable=False)
    caller_id = Column(BigInteger, ForeignKey("Users.id"), nullable=False)
    utilizator_id = Column(BigInteger, ForeignKey("Users.id"), nullable=False)
    event_status = Column(BigInteger, ForeignKey("TrashStatus.id"), default=0, nullable=False)
    time_called = Column(TIMESTAMP, nullable=False)
    time_cleaned = Column(TIMESTAMP, nullable=False)
    comment = Column(String(255), nullable=False)
    confirmation_photo_url = Column(String(255), nullable=False)
    price = Column(BigInteger, nullable=False)

    caller = relationship("User", foreign_keys=[caller_id], back_populates="called_events")
    utilizator = relationship("User", foreign_keys=[utilizator_id], back_populates="utilized_events")
    status = relationship("TrashStatus")


class Role(Base):
    __tablename__ = "Roles"

    id = Column(Integer, primary_key=True, index=True, unique=True)
    title = Column(String(60), nullable=False)

    users = relationship("User", secondary="Users_Roles", back_populates="roles")


class UsersRoles(Base):
    __tablename__ = "Users_Roles"

    id_roles = Column(BigInteger, ForeignKey("Roles.id"), primary_key=True)
    id_users = Column(BigInteger, ForeignKey("Users.id"), primary_key=True)


class TrashStatus(Base):
    __tablename__ = "TrashStatus"

    id = Column(Integer, primary_key=True, index=True, unique=True)
    title = Column(String(60), nullable=False)

\end{minted}

\begin{center}
\textbf{backend/app/router.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from . import models, schemas, database, auth
from fastapi.security import OAuth2PasswordRequestForm

router = APIRouter()

@router.post("/register", response_model=schemas.UserOut)
def register(user: schemas.UserCreate, db: Session = Depends(database.get_db)):
    db_user = db.query(models.User).filter(models.User.login == user.login).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Такой пользователь уже зарегистрирован")
    
    hashed_password = auth.get_password_hash(user.password)
    new_user = models.User(
        login=user.login, 
        mail=user.mail, 
        password=hashed_password, 
        name=user.name, 
        lastname=user.lastname, 
        surname=user.surname, 
        birthdate=user.birthdate, 
        city=user.city
    )
    
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    return new_user

@router.post("/login")
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(database.get_db)):
    user = db.query(models.User).filter(models.User.login == form_data.username).first()
    if not user or not auth.verify_password(form_data.password, user.password):
        raise HTTPException(status_code=400, detail="Неверный логин или пароль")
    
    access_token = auth.create_access_token(data={"sub": user.login})
    return {"access_token": access_token, "token_type": "bearer"}


# Включаем маршруты заявок
from .routers import events, users

main_router = APIRouter()
main_router.include_router(router, prefix="/auth", tags=["Authentication"])
main_router.include_router(events.router)
main_router.include_router(users.router)

\end{minted}

\begin{center}
\textbf{backend/app/schemas.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    login: str
    mail: EmailStr
    name: str
    lastname: str
    surname: Optional[str] = None
    birthdate: datetime
    city: str

class UserCreate(UserBase):
    password: str

class UserOut(UserBase):
    id: int

    class Config:
        orm_mode = True

class TrashEventBase(BaseModel):
    photo_url: str
    address: str
    event_status: int
    time_called: datetime
    time_cleaned: datetime
    comment: str
    confirmation_photo_url: str
    price: int

class TrashEventCreate(TrashEventBase):
    utilizator_id: int

class TrashEventOut(TrashEventBase):
    id: int
    caller_id: int
    utilizator_id: int

    class Config:
        orm_mode = True
\end{minted}

\begin{center}
\textbf{backend/app/routers/events.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
# app/routers/events.py

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from datetime import timedelta
from .. import models, schemas, database, auth
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt

router = APIRouter(prefix="/events", tags=["Events"])

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/login")

def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Функция для получения текущего пользователя
def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Невалидные учетные данные",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, auth.SECRET_KEY, algorithms=[auth.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = db.query(models.User).filter(models.User.username == username).first()
    if user is None:
        raise credentials_exception
    return user

@router.post("/", response_model=schemas.TrashEventOut)
def create_event(
    event: schemas.TrashEventCreate, 
    db: Session = Depends(database.get_db), 
    current_user: models.User = Depends(auth.get_current_user)
    ):
    new_event = models.TrashEvent(
        photo_url=event.photo_url,
        address=event.address,
        caller_id=current_user.id,
        utilizator_id=event.utilizator_id,
        event_status=event.event_status,
        time_called=event.time_called,
        time_cleaned=event.time_cleaned,
        comment=event.comment,
        confirmation_photo_url=event.confirmation_photo_url,
        price=event.price
    )
    db.add(new_event)
    db.commit()
    db.refresh(new_event)
    return new_event

@router.get("/", response_model=List[schemas.TrashEventOut])
def get_available_events(db: Session = Depends(get_db)):
    events = db.query(models.TrashEvent).filter(models.TrashEvent.status == models.TrashStatus.available).all()
    return events

@router.get("/my", response_model=List[schemas.TrashEventOut])
def get_my_events(db: Session = Depends(get_db), current_user: models.User = Depends(get_current_user)):
    events = db.query(models.TrashEvent).filter(models.TrashEvent.
    creator_id == current_user.id).all()
    return events

@router.get("/accepted", response_model=List[schemas.TrashEventOut])
def get_accepted_events(db: Session = Depends(get_db), current_user: models.User = Depends(get_current_user)):
    events = db.query(models.TrashEvent).filter(models.TrashEvent.
    accepted_by == current_user.id).all()
    return events

@router.get("/completed", response_model=List[schemas.TrashEventOut])
def get_completed_events(db: Session = Depends(get_db), current_user: models.User = Depends(get_current_user)):
    events = db.query(models.TrashEvent).filter(models.TrashEvent.status == models.TrashStatus.completed, models.TrashEvent.accepted_by == current_user.id).all()
    return events

@router.post("/{event_id}/accept", response_model=schemas.TrashEventOut)
def accept_event(event_id: int, db: Session = Depends(get_db), current_user: models.User = Depends(get_current_user)):
    event = db.query(models.TrashEvent).filter(models.TrashEvent.id == event_id, models.TrashEvent.status == models.TrashStatus.available).first()
    if not event:
        raise HTTPException(status_code=404, detail="Заявка не найдена или уже принята")
    event.status = models.TrashStatus.accepted
    event.accepted_by = current_user.id
    db.commit()
    db.refresh(event)
    return event

@router.post("/{event_id}/complete", response_model=schemas.TrashEventOut)
def complete_event(event_id: int, db: Session = Depends(get_db), current_user: models.User = Depends(get_current_user)):
    event = db.query(models.TrashEvent).filter(models.TrashEvent.id == event_id, models.TrashEvent.accepted_by == current_user.id).first()
    if not event:
        raise HTTPException(status_code=404, detail="Заявка не найдена или вы её не приняли")
    event.status = models.TrashStatus.completed
    db.commit()
    db.refresh(event)
    return event

# Получить историю заявок пользователя
@router.get("/users/{user_id}/history", response_model=List[schemas.TrashEventOut])
def get_user_request_history(user_id: int, db: Session = Depends(get_db)):
    requests = db.query(models.TrashEvent).filter(
        (models.TrashEvent.caller_id == user_id) | (models.TrashEvent.utilizator_id == user_id),
        models.TrashEvent.status == models.TrashStatus.completed
    ).all()
    return requests
\end{minted}

\begin{center}
\textbf{backend/app/routers/users.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from .. import models, database, schemas, auth
from typing import List

router = APIRouter(prefix="/users", tags=["Users"])

# Получить всех пользователей
@router.get("/", response_model=List[schemas.UserOut])
def get_users(db: Session = Depends(database.get_db)):
    users = db.query(models.User).all()
    return users

@router.get("/{user_id}")
def get_users(user_ud: int, db: Session = Depends(database.get_db)):
    users = db.query(models.User).all()
    return users

# Удалить пользователя
@router.delete("/{user_id}")
def delete_user(user_id: int, db: Session = Depends(database.get_db)):
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Пользователь не найден")
    db.delete(user)
    db.commit()
    return {"detail": "Пользователь удален"}

# Обновить информацию о пользователе
@router.put("/{user_id}", response_model=schemas.UserOut)
def update_user(user_id: int, user_update: schemas.UserCreate, db: Session = Depends(database.get_db)):
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Пользователь не найден")
    
    user.login = user_update.login
    user.mail = user_update.mail
    user.password = auth.get_password_hash(user_update.password)
    user.name = user_update.name
    user.lastname = user_update.lastname
    user.surname = user_update.surname, 
    user.birthdate = user_update.birthdate, 
    user.city = user_update.city        
    
    db.commit()
    db.refresh(user)
    return user
\end{minted}

\begin{center}
\textbf{backend/docker-compose.yml}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{YAML}
    services:
    web:
      build: .  # Эта строка говорит Compose использовать Dockerfile в текущей директории
      container_name: fastapi-app
      restart: always
      volumes:
        - .:/app  # Монтируем локальную папку в контейнер
      ports:
        - "8080:8000"
      depends_on:
        - db
      environment:
        - DATABASE_URL=postgresql://meebin_user:password@db/meebin_db
  
    db:
      image: postgres:16.3
      container_name: postgres-db
      environment:
        POSTGRES_USER: meebin_user
        POSTGRES_PASSWORD: password
        POSTGRES_DB: meebin_db
      ports:
        - "5432:5432"
      volumes:
        - postgres-data:/var/lib/postgresql/data
        - ./init.sql:/docker-entrypoint-initdb.d/init.sql
  
    alembic:
      build: .
      container_name: alembic
      volumes:
        - .:/app
      depends_on:
        - db
      environment:
        - DATABASE_URL=postgresql://meebin_user:password@db/meebin_db
      command: alembic upgrade head
  
  volumes:
    postgres-data:  
\end{minted}

\begin{center}
\textbf{backend/Dockerfile}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{Dockerfile}
    # Используем официальный Python образ
    FROM python:3.11-slim
    
    # Устанавливаем зависимости
    WORKDIR /app
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    
    # Копируем все файлы в контейнер
    COPY . .
    
    COPY init.sql /docker-entrypoint-initdb.d/
    
    # Открываем порт 8000
    EXPOSE 8000
    
    # Команда запуска FastAPI приложения
    CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
\end{minted}

\begin{center}
\textbf{backend/alembic/env.py}
\end{center}

\begin{minted}[linenos, breaklines=true, style=bw]{python}
# alembic/env.py

import sys
import os
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context

# Добавляем путь к проекту
sys.path.append(os.path.abspath(os.path.join(
    os.path.dirname(__file__), '..', 'app')))

from app.database import Base
from app import models  # Убедитесь, что ваши модели импортируются

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)

# Добавьте ваши модели здесь
target_metadata = Base.metadata

def run_migrations_offline():
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=target_metadata, literal_binds=True, dialect_opts={"paramstyle": "named"}
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
\end{minted}

\end{document}
